<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Exec</title>
    <url>/2022/09/11/Exec/</url>
    <content><![CDATA[<h2 id="Exec"><a href="#Exec" class="headerlink" title="Exec"></a>Exec</h2><p>在进入靶场后发现窗口ping，猜测可能是SQL注入漏洞，也有可能是命令执行漏洞。</p>
<p>先ping一下本机地址127.0.0.1</p>
<p>有回显，所以是命令执行漏洞。</p>
<p><img src="/../images/Exec/image-20230911105131441.png" alt="image-20230911105131441"></p>
<hr>
<p>在 Web 应用中有时候程序员为了考虑灵活性、简洁性，会在代码调用代码或命令执行函数去处理。比如当应用在调用一些能将字符串转化成代码的函数时，没有考虑用户是否能控制这个字符串，将造成代码执行漏洞。同样调用系统命令处理，将造成命令执行漏洞。</p>
<p>命令执行漏洞的原理是由于应用程序未正确对用户输入进行验证和过滤，导致用户输入被直接或间接地作为命令或代码的一部分执行。攻击者利用这个漏洞，通过注入恶意代码或命令，让应用程序误以为这是合法的输入，从而在目标系统上执行恶意操作。</p>
<h3 id="命令拼接符"><a href="#命令拼接符" class="headerlink" title="命令拼接符:"></a>命令拼接符:</h3><p>命令执行就用命令拼接符执行漏洞命令就行。常见的命令拼接符为以下四种。<br>&amp;:无论左边是false还是true，右边都执行。<br>&amp;&amp;:具有短路效果，左边是false，右边不执行。<br>|:无论左边是false还是true，右边都执行。</p>
<p>||:具有短路效果，左边是true，右边不执行</p>
<hr>
<p>试着查看目录127.0.0.1 &amp;&amp; ls 没反应，试试127.0.0.1 &amp; ls 有回显</p>
<p>发现index.php文件，进入。</p>
<p>查看所有根目录Windows系统为dir，linux为 ls/，猜测为Linux系统先试试127.0.0.1 &amp; ls /(或者127.0.0.1 | ls)</p>
<p>得到目录发现有一个flag文件，flag应该在里面，进行查看。127.0.0.1 &amp; cat /flag（或者127.0.0.1 | cat /flag）</p>
<p>拿到flag!</p>
<p><img src="/../images/Exec/image-20230911105144151.png" alt="image-20230911105144151"></p>
]]></content>
      <categories>
        <category>buuctf</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>命令执行漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>N1book</title>
    <url>/2023/09/15/N1book/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="常见信息收集"><a href="#常见信息收集" class="headerlink" title="常见信息收集"></a>常见信息收集</h2><p><img src="/../images/N1book/image-20230915145523146.png" alt="image-20230915145523146"></p>
<p>进入靶场查看源码没有收获，使用工具对网站目录进行扫描。</p>
<p>dirb没扫到，改用dirsearch。</p>
<p><img src="/../images/N1book/image-20230917122519644.png" alt="image-20230917122519644"></p>
<p>发现存在<code>robots.txt</code>,<code>index.php~</code>,<code>.index.php.swp</code>等文件，分别存放了flag的3个部分</p>
<pre class="language-none"><code class="language-none">- `robots.txt`:告诉爬虫哪些页面可以爬取
- `index.php~`:php的备份有两种：`*.php~`和`*.php.bak`
- `.index.php.swp`:当vim出现异常会产生`.swp`文件，可以通过`vim -r .index.php.swp`恢复文件</code></pre>

<p>访问robots.txt</p>
<p><img src="/../images/N1book/image-20230915160035966.png" alt="image-20230915160035966"></p>
<p>得到flag存放信息继续访问提示文件</p>
<p><img src="/../images/N1book/image-20230915160114816.png" alt="image-20230915160114816"></p>
<p>拿到部分flag。</p>
<p><img src="/../images/N1book/image-20230915160206249.png" alt="image-20230915160206249"></p>
<p>访问index.php~拿到第二部分flag。</p>
<p>访问.index.php.swp</p>
<p><img src="/../images/N1book/image-20230915160451066.png" alt="image-20230915160451066"></p>
<p>下载文件查看。</p>
<p><img src="/../images/N1book/image-20230915160806614.png" alt="image-20230915160806614"></p>
<p>拿到第三部分flag。拼接在一起。</p>
<p><img src="/../images/N1book/image-20230915160921280.png" alt="image-20230915160921280"></p>
<h2 id="粗心的小李"><a href="#粗心的小李" class="headerlink" title="粗心的小李"></a>粗心的小李</h2><p><img src="/../images/N1book/image-20230918162128927.png" alt="image-20230918162128927"></p>
<p>进入靶场，可以看到是和git泄露漏洞相关。</p>
<h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。当前大量开发人员使用git进行版本控制，对站点自动部署。攻击者可以利用该漏洞下载git文件夹里的所有内容。如果文件夹内有敏感信息比如站点源码、数据库账户密码等，攻击者可能直接控制服务器。如果配置不当，可能会将.git文件夹直接部署到线上环境。这就引起了git泄露漏洞。</p>
<h3 id="git目录"><a href="#git目录" class="headerlink" title=".git目录"></a>.git目录</h3><pre class="language-none"><code class="language-none">config - 包含一些配置选项
description - 仓库的描述信息，主要给gitweb等git托管系统使用
HEAD - 指定当前分支,映射到ref引用，能够找到下一次commit的前一次哈希值
hooks - 存放可在某些指令前后触发运行的钩子脚本（hook scripts），默认包含一些脚本样例
index - 这个文件就是我们前面提到的暂存区（stage），是一个二进制文件
info - 存放仓库的信息
objects - 存储所有Git的数据对象,对象的SHA1哈希值的前两位是文件夹名称，后38位作为对象文件名
refs - 存储各个分支指向的目标提交
</code></pre>

<p><a href="https://zhuanlan.zhihu.com/p/455435143%EF%BC%88Git%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93%EF%BC%89">https://zhuanlan.zhihu.com/p/455435143（Git信息泄露原理解析及利用总结）</a></p>
<p>使用dirsearch工具扫描，需要设置扫描间隔时间和线程数，默认情况无法扫描。本次使用的单线程模式且间隔时间为0.1.</p>
<p><a href="https://blog.csdn.net/m0_37268841/article/details/125565452">https://blog.csdn.net/m0_37268841/article/details/125565452</a></p>
<p>（dirsearch工具常见参数）</p>
<p><img src="/../images/N1book/image-20230918163952795.png" alt="image-20230918163952795"></p>
<p>证明存在git泄露漏洞</p>
<p>使用githack工具泄露的文件（python2运行）或者scrabble。</p>
<p>会得到一个index.html文件打开拿到flag。</p>
<h2 id="SQL注入1"><a href="#SQL注入1" class="headerlink" title="SQL注入1"></a>SQL注入1</h2><p><img src="/../images/N1book/image-20230918165610498.png" alt="image-20230918165610498"></p>
<p>进入靶场，看似有输入表单点击无反应。直接在url注入，尝试1.2</p>
<p><img src="/../images/N1book/image-20230918165828443.png" alt="image-20230918165828443"></p>
<p><img src="/../images/N1book/image-20230918165837170.png" alt="image-20230918165837170"></p>
<p><img src="/../images/N1book/image-20230918165909456.png" alt="image-20230918165909456"></p>
<p>插入‘变化所以是字符注入，</p>
<p>测试注入列数</p>
<p>Index.php?id=1’ order by 3 –+</p>
<p><img src="/../images/N1book/image-20230918170021585.png" alt="image-20230918170021585"></p>
<p>测试注入点</p>
<p><img src="/../images/N1book/image-20230918170246786.png" alt="image-20230918170246786"></p>
<p>测试数据库</p>
<p><img src="/../images/N1book/image-20230918170322140.png" alt="image-20230918170322140"></p>
<p>测表名</p>
<p><img src="/../images/N1book/image-20230918170544720.png" alt="image-20230918170544720"></p>
<p>查列名</p>
<p><img src="/../images/N1book/image-20230918170711429.png" alt="image-20230918170711429"></p>
<p>查看表里数据</p>
<p><img src="/../images/N1book/image-20230918170928545.png" alt="image-20230918170928545"></p>
<p>使用sqlmap试试。</p>
<p><img src="/../images/N1book/image-20230918171103395.png" alt="image-20230918171103395"></p>
<!-- more -->

]]></content>
      <categories>
        <category>buuctf</category>
      </categories>
      <tags>
        <tag>buuctf</tag>
        <tag>N1book</tag>
        <tag>web入门</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper</title>
    <url>/2024/02/27/ZooKeeper/</url>
    <content><![CDATA[<h2 id="ZooKeeper概念"><a href="#ZooKeeper概念" class="headerlink" title="ZooKeeper概念"></a>ZooKeeper概念</h2><ul>
<li>zookeeper是apache Hadoop项目下的一个子项目，是一个树形目录服务。</li>
<li>Zookeeper翻译过来就是动物园管理员，用来管理Hadoop（大象）、Hive（蜜蜂）、Pig</li>
<li>分布式的，开源的分布式应用程序的协调服务</li>
<li>主要功能包括：<ul>
<li>配置管理</li>
<li>分布式锁</li>
<li>集群管理</li>
</ul>
</li>
</ul>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>Zookeeper:一个领导者（Leader)，多个跟随者（Follower）组成的集群。</li>
<li>集群中只要有半数以上节点存活，Zookeeper集群就能正常服务。所以Zookeeper适合安装奇数台服务器。</li>
<li>全局数据一致:每个Server保存一份相同的数据副本，Client无论连接到哪个Server，数据都是一致的。</li>
<li>更新请求顺序执行，来白同一个Client的更新请求按其发送顺序依次执行。</li>
<li>数据更新原子性，一次数据更新要么成功，要么失败。</li>
<li>实时性,在一定时间范围内，Client能读到最新数据。</li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><img src="/../images/ZooKeeper/image-20240301162933691.png" alt="image-20240301162933691"></p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>ZooKeeper</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2222/09/01/hello-world/</url>
    <content><![CDATA[<span id="more"></span>

<p>记录美好</p>
<!-- more -->

]]></content>
  </entry>
  <entry>
    <title>sql注入</title>
    <url>/2024/03/03/sql%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h2 id="sql注入原理"><a href="#sql注入原理" class="headerlink" title="sql注入原理"></a>sql注入原理</h2><p>sql注入本质就是把用户输入的参数当作SQL语句执行，web应用程序对用户输入数据的合法性没有判断和过滤，攻击者可以通过构造不同的SQL语句来实现对数据库的操作。其可能造成信息泄露，上传webshell，篡改网页信息等。</p>
<p>sqlmap常用注入语句</p>
<ol>
<li>扫描目标URL：sqlmap -u &lt;目标URL&gt;</li>
<li>扫描目标URL并检测注入：sqlmap -u &lt;目标URL&gt; –dbs</li>
<li>指定注入参数进行测试：sqlmap -u &lt;目标URL&gt; -p &lt;注入参数&gt;</li>
<li>指定数据库类型进行测试：sqlmap -u &lt;目标URL&gt; –dbms &lt;数据库类型&gt;</li>
<li>使用Cookie进行测试：sqlmap -u &lt;目标URL&gt; –cookie “&lt;Cookie数据&gt;”</li>
<li>执行具体的SQL注入攻击：sqlmap -u &lt;目标URL&gt; –data “&lt;POST数据&gt;” –method POST –level 5 –risk 3</li>
</ol>
<h2 id="SQL注入分类"><a href="#SQL注入分类" class="headerlink" title="SQL注入分类"></a>SQL注入分类</h2><h3 id="联合注入"><a href="#联合注入" class="headerlink" title="联合注入"></a>联合注入</h3><p>sql注入一般流程：</p>
<ol>
<li>判断注入点是否存在以及类型</li>
<li>order by猜字段数</li>
<li>联合查询寻找输出点</li>
<li>查库名 union select 1,2,3,database()</li>
<li>查表名 </li>
<li>查字段</li>
</ol>
<h3 id="头部注入"><a href="#头部注入" class="headerlink" title="头部注入"></a>头部注入</h3><p>HTTP头部注入是指注入字段在HTTP请求头的字段中，一般是user-agent，referer。</p>
<p>user-agent：提供浏览器类型，操作系统版本，插件信息等</p>
<p>referer：指明当前请求来自那里</p>
<h4 id="user-agent案例-以sqllibs18为例"><a href="#user-agent案例-以sqllibs18为例" class="headerlink" title="user-agent案例-以sqllibs18为例"></a>user-agent案例-以sqllibs18为例</h4><p><img src="/../images/sql%E6%B3%A8%E5%85%A5/image-20240303144412570.png" alt="image-20240303144412570"></p>
<p>输入用户名和密码发现屏幕回显user-agent</p>
<p><img src="/../images/sql%E6%B3%A8%E5%85%A5/image-20240303145726412.png" alt="image-20240303145726412"></p>
<p>猜测注入点可能在此bp抓包看看</p>
<p><img src="/../images/sql%E6%B3%A8%E5%85%A5/image-20240303145942758.png" alt="image-20240303145942758"></p>
<p>修改user-agent后面内容试试，改为 ’</p>
<p><img src="/../images/sql%E6%B3%A8%E5%85%A5/image-20240303150234394.png" alt="image-20240303150234394"></p>
<p>发现报错，闭合方式应该为‘#</p>
<p><img src="/../images/sql%E6%B3%A8%E5%85%A5/image-20240303151704182.png" alt="image-20240303151704182"></p>
<p>接下来入正常进行即可。</p>
<h3 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h3><p>在攻击过程中服务器开启错误回显，页面会返回错误信息，利用报错函数来获取信息</p>
<ol>
<li>updatexml()</li>
</ol>
<p>updatexml(XML_document,XPayh_string,new_value);</p>
<p>简单来说就是updatexml(目标xml内容，xml文档路径，更新的内容)</p>
<p>我们在xml文档路径写入了子查询，和特俗字符拼接在其，因为不符合输入路径规则报错，先执行了子查询可以得到我们需要的消息。0x7e是~的16进制表示。</p>
<p>语句L:select * from aaa where id=1 and updatexml(1,concat（0x7e,(select user()),1)</p>
<ol start="2">
<li>floor()</li>
</ol>
<p>floor和count和group by三个函数在一起会报错。</p>
<p>语句：select * from aaa where id=1 and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a);</p>
<ol start="3">
<li>extractvalue()</li>
</ol>
<p>原理同updatexml().</p>
<p>语句：select * from aaa where id =1 and(extractvalue(1,concat(0x7e,(select user(),0x7e)));</p>
<h3 id="布尔型盲注"><a href="#布尔型盲注" class="headerlink" title="布尔型盲注"></a>布尔型盲注</h3><p>主要用于网站无输出点，并且关闭了错误回显。</p>
<p>常用函数：</p>
<ul>
<li>length（）：函数返回值为字符串长度。</li>
<li>substr():截取字符串，substr(string,start,length)</li>
<li>ascii():返回字符串中第一关字符的ascii值</li>
</ul>
<h3 id="延时注入"><a href="#延时注入" class="headerlink" title="延时注入"></a>延时注入</h3><p>有时候会遇到无论如何操作页面返回都是正常的情况，这时候考虑使用延时注入</p>
<p>使用函数：sleep（）。</p>
<h3 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h3><p>在一些老版本的php中可以开启防御函数magic_quotes_gpc，也叫魔术引号，作用是判断用户提交的数据，包括有get、post、cookie过来的数据里面的特殊字符增加转义字符”\”，以确保这些数据不会因为特殊字符引起的污染而出现致命的错误。单引号(‘)、双引号(“)、反斜线（\）等字符都会被加上反斜线。</p>
<p>因为单引号和双引号里面的内容都是字符串，如果我们输入的东西不能闭合掉单引号双引号，就无法产生sql注入，在新版本中虽然取消了魔术引号，但是很多cms依然会用一些函数替代，比如addslashes()等。</p>
<p>那么我们怎么逃逸出这个转义呢？这时候可以使用宽字节注入。</p>
<p>原理：如果程序设计数据库编码的时候设置了非英文编码，php发送请求到mysql时经过一次gbk编码，因为gbk是双字节编码，当设置gbk编码后，遇到了连续两个字节都符合gbk取值范围，会自动解析成一个汉字，输入%df%27，本来\会转义%27（’）,但\（%5c）的编码数为92，%df的编码数为223，符合取值范围，于是%df%5c会解析成为一个汉字“運”，单引号就逃逸了出来，从而绕过转义造成注入。</p>
<ul>
<li>注：1.POST注入并不会进行URL转码，所以需要改hex。</li>
<li>2.在查询时用到的表名字段名不能用原来的‘admin’形式，这时候可以转换十六进制，或者用子查询。</li>
<li>3.还可以用汉字绕过。</li>
</ul>
<h3 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h3><p>在SQL中，分号表示一条SQL语句的介绍，在结束语句后再构造一条语句，就会造成堆叠注入。</p>
<h3 id="DNSlog注入"><a href="#DNSlog注入" class="headerlink" title="DNSlog注入"></a>DNSlog注入</h3><p>利用场景：在某些无法直接利用漏洞获得回显时如果用盲注来做效率低下且容易被waf拦截，但是目标可以发起请求，这个时候我们可以通过DNS解析把我们想要获得的数据外带出来。</p>
<p>注入过程：通过子查询将内容拼接到域名内，让load_file()去访问共享文件，访问的域名被记录，读取远程共享文件，通过拼接出函数做查询，拼接到域名中，访问时将访问服务器，记录后查询该日志。</p>
<p>这里需要用到一个mysql函数LOAD_FILE()：读取一个文件并将其内容作为字符串返回。</p>
]]></content>
      <categories>
        <category>web漏洞</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title>train-www-robots</title>
    <url>/2022/09/11/train-www-robots/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="training-www-Robots"><a href="#training-www-Robots" class="headerlink" title="training-www-Robots"></a>training-www-Robots</h2><h3 id="考察的知识点"><a href="#考察的知识点" class="headerlink" title="考察的知识点"></a>考察的知识点</h3><p>robots.txt 文件是一个文本文件，使用任何一个常见的文 本编辑器，比如 Windows 系统自带的 Notepad，就可以创 建和编辑它[1] 。robots.txt 是一个协议，而不是一个命令。 robots.txt 是搜索引擎中访问网站的时候要查看的第一个 文件。robots.txt 文件告诉蜘蛛程序在服务器上什么文件 是可以被查看的。 当一个搜索蜘蛛访问一个站点时，它会首先检查该站点根 目录下是否存在 robots.txt，如果存在，搜索机器人就会 按照该文件中的内容来确定访问的范围；如果该文件不存 在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保 护的页面。百度官方建议，仅当您的网站包含不希望被搜 索引擎收录的内容时，才需要使用 robots.txt 文件。如果 您希望搜索引擎收录网站上所有内容，请勿建立 robots.txt 文件。 如果将网站视为酒店里的一个房间，robots.txt 就是主人 在房间门口悬挂的“请勿打扰”或“欢迎打扫”的提示牌。这 个文件告诉来访的搜索引擎哪些房间可以进入和参观，哪 些房间因为存放贵重物品，或可能涉及住户及访客的隐私 而不对搜索引擎开放。但 robots.txt 不是命令，也不是防 火墙，如同守门人无法阻止窃贼等恶意闯入者。</p>
<p><a href="https://zhuanlan.zhihu.com/p/29675312#:~:text=%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFRobots%E5%8D%8F%E8%AE%AE%EF%BC%9F,Robots%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B9%9F%E7%A7%B0%E4%B8%BA%E7%88%AC%E8%99%AB%E5%8D%8F%E8%AE%AE%E3%80%81%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8D%8F%E8%AE%AE%E7%AD%89%EF%BC%89%E7%9A%84%E5%85%A8%E7%A7%B0%E6%98%AF%E2%80%9C%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E6%8E%92%E9%99%A4%E6%A0%87%E5%87%86%E2%80%9D%EF%BC%8Crobots.txt%E6%98%AF%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E8%AE%BF%E9%97%AE%E7%BD%91%E7%AB%99%E6%97%B6%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%9F%A5%E7%9C%8B%E7%9A%84%E6%96%87%E4%BB%B6%EF%BC%8C%E5%BD%93%E6%88%91%E4%BB%AC%E7%BD%91%E7%AB%99%E6%9C%89%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%E4%B8%8D%E5%B8%8C%E6%9C%9B%E6%94%B6%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%8A%93%E5%8F%96%E6%97%B6%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87Robots%E5%8D%8F%E8%AE%AE%E6%9D%A5%E5%91%8A%E8%AF%89%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%93%AA%E4%BA%9B%E9%A1%B5%E9%9D%A2%E6%98%AF%E4%B8%8D%E8%83%BD%E6%8A%93%E5%8F%96%E7%9A%84%EF%BC%8C%E5%A4%A7%E5%A4%9A%E7%94%A8%E6%9D%A5%E4%BF%9D%E6%8A%A4%E7%BD%91%E7%AB%99%E7%9A%84%E9%9A%90%E7%A7%81%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E6%AD%BB%E9%93%BE%E3%80%81%E9%87%8D%E5%A4%8D%E9%A1%B5%E9%9D%A2%E7%AD%89%E7%AD%89%E3%80%82">什么是robots协议？robots.txt文件怎么写？ - 知乎 (zhihu.com)</a></p>
<p><img src="/../images/traning-www-robots/image-20230910204135962.png" alt="image-20230910204135962"></p>
<p>打开网页得到这个阅读一下，发现使用robots</p>
<p>在网页链接加上robots.txt</p>
<p><img src="/../images/traning-www-robots/image-20230910204201240.png" alt="image-20230910204201240"></p>
<p>看到flag信息查看flag</p>
<p><img src="/../images/traning-www-robots/image-20230910204211916.png" alt="image-20230910204211916"></p>
<p>拿到flag。</p>
]]></content>
      <categories>
        <category>攻防世界</category>
      </categories>
      <tags>
        <tag>-web -robots</tag>
      </tags>
  </entry>
  <entry>
    <title>upload-labs1</title>
    <url>/2023/09/14/upload-labs1/</url>
    <content><![CDATA[<h2 id="upload-labs-1"><a href="#upload-labs-1" class="headerlink" title="upload-labs-1"></a>upload-labs-1</h2><p><img src="/../images/upload-labs1/image-20230914142612836.png" alt="image-20230914142612836"></p>
<h3 id="关卡简介："><a href="#关卡简介：" class="headerlink" title="关卡简介："></a>关卡简介：</h3><p>上传点使用前端来验证后缀名，使用bp绕过上传木马脚本获取webshell。</p>
<h3 id="查看源码"><a href="#查看源码" class="headerlink" title="查看源码"></a>查看源码</h3><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">checkFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> file <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByName</span><span class="token punctuation">(</span><span class="token string">' upload_file'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>file <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> file <span class="token operator">==</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"请选择要上传的文件!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//定义允许上传的文件类型</span>
    <span class="token keyword">var</span> allow_ext <span class="token operator">=</span> <span class="token string">".jpg|.png|.gif"</span><span class="token punctuation">;</span>
    <span class="token comment">//提取上传文件的类型</span>
    <span class="token keyword">var</span> ext_name <span class="token operator">=</span> file<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//判断上传文件类型是否允许上传</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>allow_ext<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>ext_name <span class="token operator">+</span> <span class="token string">"|"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> errMsg <span class="token operator">=</span> <span class="token string">"该文件不允许上传，请上传"</span> <span class="token operator">+</span> allow_ext <span class="token operator">+</span> <span class="token string">"类型的文件,当前文件类型为："</span> <span class="token operator">+</span> ext_name<span class="token punctuation">;</span>
        <span class="token function">alert</span><span class="token punctuation">(</span>errMsg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>

<p>只允许上传.jpg|.png|.gif类型文件</p>
<p><img src="/../../../zy/Documents/image-20230914150230885.png" alt="image-20230914150230885"></p>
<p>1.查看前端代码删除check函数，或者禁用js</p>
<p><img src="/../images/upload-labs1/image-20230914150556990.png" alt="image-20230914150556990"></p>
<p>2.bp抓包修改后缀</p>
]]></content>
      <tags>
        <tag>uoload-labs</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传</title>
    <url>/2023/09/14/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><p><img src="/../images/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/1627433334141-cb693e43-53e8-4e28-80b9-b2c08e23f2f6.png" alt="web漏洞文件上传.png"></p>
<h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>在某处用户可以上传文件到服务器端，比如个人资料，头像，且后端不对用户上传的文件做处理，攻击者可以利用这个功能上传恶意文件，比如木马，病毒，恶意脚本，后门等。</p>
<h2 id="利用："><a href="#利用：" class="headerlink" title="利用："></a>利用：</h2><p>各种绕过，上传一句话木马。</p>
<p><img src="/../images/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/1627433817849-28573285-fa9c-4d1d-9864-2f822f372ee5.png" alt="文件上传利用思路.png"></p>
<h2 id="文件上传漏洞如何查找及判断"><a href="#文件上传漏洞如何查找及判断" class="headerlink" title="文件上传漏洞如何查找及判断?"></a>文件上传漏洞如何查找及判断?</h2><p>1.黑盒查找：通过工具扫描网站敏感文件、路径，以期获得文件上传地址。或者通过类似于会员中心的上传图片功能进行漏洞测试。网站后台也有上传功能（后台权限不等同于网站权限）。</p>
<p>2.白盒测试：审计代码，寻找上传漏洞。通过抓包、上传等操作判断漏洞是否有效。</p>
<h3 id="文件上传常见验证"><a href="#文件上传常见验证" class="headerlink" title="文件上传常见验证:"></a>文件上传常见验证:</h3><p>后缀名，类型，文件头等<br>后缀名:黑名单,白名单<br>文件类型:MIME<br>信息文件头:内容头信息</p>
<p>简要上传表单代码分析解释</p>
<h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><pre class="language-none"><code class="language-none">trim() 函数移除字符串两侧的空白字符或其他预定义字符。

str_ireplace() 函数替换字符串中的一些字符（不区分大小写）。

substr() 函数返回字符串的一部分。

strrpos() 函数查找字符串在另一字符串中最后一次出现的位置。</code></pre>



<h2 id="防御："><a href="#防御：" class="headerlink" title="防御："></a>防御：</h2><p>1.前端js脚本检测后缀名。（可以有burp抓包修改文件后缀名绕过）</p>
<p>2.后端黑白名单检测（黑名单检测可以通过测试检测规则绕过，白名单检测可以用00截断绕过）</p>
<p>3.content-type检测过滤（bp抓包修改content-type绕过）</p>
<p>4.getimagesize(_)函数检测图片大小是否正常（将木马写入图片绕过）</p>
<p>5.图片二次渲染</p>
<p>6.文件重命名</p>
<h2 id="常见绕过方式"><a href="#常见绕过方式" class="headerlink" title="常见绕过方式"></a>常见绕过方式</h2><p>数据溢出-防匹配(xxx.. .)</p>
<p>符号变异-防匹配（’” ;)</p>
<p>数据截断-防匹配(%00 ;换行)</p>
<p>重复数据-防匹配(参数多次)</p>
<h2 id="上传的参数名解析"><a href="#上传的参数名解析" class="headerlink" title="上传的参数名解析"></a>上传的参数名解析</h2><p>可以修改的东西有？</p>
<pre class="language-none"><code class="language-none">Content-Disposition:	一般可更改

name:	表单参数值，不能更改

filename :文件名，可以更改

Content-Type:文件MIME，视情况更改
</code></pre>

]]></content>
      <tags>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>owasp top10</title>
    <url>/2024/03/05/owasp-top10/</url>
    <content><![CDATA[<h2 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h2><p>注入通常是指将不受信任的数据作为命令或查询的一部分发送到解析器时，会产生注入SQL注入、OS注入和LDAP注入的缺陷。攻击者的恶意数据可以诱使解析器在没有适当授权的情况下执行非预期命令访问数据。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>一般常见的SQL注入和OS注入</p>
<ul>
<li><p>SQL注入：</p>
</li>
<li><p>SQL注入防御：</p>
<ol>
<li>对输入进行严格过滤和转义</li>
<li>关闭错误回显</li>
<li>限制SQL服务的远程访问，只开放给特定开发人员</li>
<li>代码审计–最有效的检测应用程序的注入风险的方法之一</li>
<li>使用成熟的waf</li>
</ol>
</li>
<li><p>os注入：web开发使用的编程语言中，大多数能通过shell执行os命令。通过shell执行OS命令时或者开发中用到某个方法其内部利用了shell时，就有可能出现OS命令被任意执行的情况。</p>
</li>
<li><p>OS注入的防御：</p>
<ol>
<li>使用安全的函数对传递给OS命令参数进行转义</li>
<li>不将外界传入的字符串传递给命令行参数</li>
<li>选择不调用OS命令的方法实现</li>
</ol>
<p>（不利用 shell的功能，既能杜绝os命令注入漏洞，又消除了调用os命令的系统开销，提高应用性能）</p>
</li>
</ul>
<h2 id="敏感数据泄露"><a href="#敏感数据泄露" class="headerlink" title="敏感数据泄露"></a>敏感数据泄露</h2><p>原理：应用维护或者开发人员无意间上传敏感数据，如GitHub文件泄露敏感数据文件的权限设置错误。</p>
<p>常见攻击方式主要是扫描应用程序获得敏感数据</p>
<p>防御：</p>
<ol>
<li>对系统处理、存储或传输的数据分类进行访问控制。</li>
<li>确保存储的敏感数据被加密</li>
<li>确保使用了强大的标准算法或密码、参数。协议和秘钥，</li>
<li>禁止缓存对包含敏感数据的响应</li>
</ol>
<h2 id="失效的身份认证"><a href="#失效的身份认证" class="headerlink" title="失效的身份认证"></a>失效的身份认证</h2><p>原理：应用中负责认证会话管理的部分没有正确实现，使得攻击者得以泄露密码，口令或令牌，进而可能获取其他用户的身份。</p>
<p>影响：</p>
<ul>
<li>盗用账号与身份（撞库，弱密码尝试之类）</li>
</ul>
<p>防御：</p>
<ul>
<li>使用强密码</li>
<li>限制或延迟失败的登录尝试，并记录所有失败尝试</li>
<li>网站应该具备良好的权限控制与管理</li>
<li>使用SSL对数据流进行加密</li>
</ul>
<h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>往网站上注入恶意脚本，当用户浏览网页时候恶意代码执行，从而获取用户敏感信息。分为存储型，DOM型，反射型</p>
<h4 id="反射型XSS："><a href="#反射型XSS：" class="headerlink" title="反射型XSS："></a>反射型XSS：</h4><p>非持久化攻击，需要欺骗用户点击链接才能触发XSS代码。应用程序或API包括未验证和未转义的用户输入作为html输出的一部分。</p>
<h4 id="存储型XSS："><a href="#存储型XSS：" class="headerlink" title="存储型XSS："></a>存储型XSS：</h4><p> 持久化攻击，代码存在服务器中，如个人信息里。访问该页面时候触发代码执行，容易造成蠕虫，盗窃cookie。</p>
<h4 id="DOM型："><a href="#DOM型：" class="headerlink" title="DOM型："></a>DOM型：</h4><p>不经过后端，domxss是基于文档对象模型（document object model，dom)的漏洞</p>
<p>，攻击者向服务器发送一个带有恶意js代码的请求，服务器的响应不i会以任何形式包含攻击者的脚本。当用户的浏览器处理这个响应时，DOM对象就会处理XSS代码，导致XSS漏洞。</p>
<h4 id="防御："><a href="#防御：" class="headerlink" title="防御："></a>防御：</h4><ul>
<li>存储型：后台编写过滤器，对一些HTML标签和特殊的字符进行转义</li>
<li>反射型：对特殊字符转义</li>
<li>dom:检测是否包含一些特殊的函数可以造成危害的地方</li>
<li>使用字段转义的xss框架，如react js</li>
<li>启用CSP（content security policy），这是一种对抗XSS纵深防御弥补控制。</li>
</ul>
<h2 id="外部实体（XXE）"><a href="#外部实体（XXE）" class="headerlink" title="外部实体（XXE）"></a>外部实体（XXE）</h2><p>XXE（XML external entity injection）外部实体注入漏洞，XML在引用外部实体时候，攻击者可以构造恶意的XML代码，以造成任意文件读取、命令执行甚至是中断服务器。</p>
<p>主要成因是因为XML协议文档本身的设计特性，可以引入外部的资源，定义XML文件时使用的外部实体引入功能。 </p>
<p>影响：读取服务器敏感资料比如/etc/password</p>
<p>读取源码</p>
<p>防御：关闭DTD，禁止外部实体引入，过滤用户提交的XML数据</p>
<h2 id="安全配置错误"><a href="#安全配置错误" class="headerlink" title="安全配置错误"></a>安全配置错误</h2><p>原理：操作者不当配置（默认配置，临时配置，开源云存储，HTTP标头配置），导致攻击者可以利用这些配置获取到更高权限，安全配置错误可以发生在各个层面，包含平台、web服务器、数据库、架构和代码</p>
<p>防御：</p>
<ul>
<li>使用的服务不包含任何不必要的功能、组件、文档和用例，移除或不安装不适用的功能和框架</li>
<li>即使检测系统服务版本打上漏洞补丁</li>
<li>自动化安装部署</li>
</ul>
<h2 id="失效访问控制"><a href="#失效访问控制" class="headerlink" title="失效访问控制"></a>失效访问控制</h2><p>水平越权：系统只验证能够访问数据的角色没有对数据做细分导致A能访问B的数据。</p>
<p>垂直越权：后台未对权限做限制，导致攻击者可以通过猜测其他管理页面的url或者敏感的参数信息变更权限。</p>
<p>防御：</p>
<ul>
<li>对参数的白名单过滤</li>
<li>对权限的控制管理重新设计与限制</li>
<li>前后端同时校验，双重验证机制</li>
<li>用户注销后使其jwt令牌失效</li>
</ul>
<h2 id="不安全的反序列化"><a href="#不安全的反序列化" class="headerlink" title="不安全的反序列化"></a>不安全的反序列化</h2><p>介绍：</p>
<p>序列化：序列化 (Serialization)是将对象的状态信息转换为可以存储或传输(一般是以二进制的形式保存)的形式的过程。<br>反序列化： 与序列化的过程刚好相反。</p>
<p>原理：如果应用对恶意构造的用户输入数据进行反序列化，会产生非预期对象，从而可能导致远程代码执行。或者应用中存在可以反序列化过程中或者之后被改变行为的类，则攻击者可以通过改变应用逻辑或者失实现远程代码执行攻击，称为对象和数据结构攻击。</p>
<p>防御</p>
<ol>
<li>对序列化对象进行完整性检测，比如数字签名防止数据篡改或恶意对象。</li>
<li>在反序列化过程中强制严格的类型限制</li>
<li>在低权限环境中独立运行反序列化代码</li>
<li>不接受来自不信任源的序列化对象，或使用只允许原始数据类型的序列化媒体</li>
<li>对反序列化过程进行日志记录，监控反序列化过程，在发现疑似反序列化攻击时进行警报。</li>
</ol>
<h2 id="使用含已知漏洞的组件"><a href="#使用含已知漏洞的组件" class="headerlink" title="使用含已知漏洞的组件"></a>使用含已知漏洞的组件</h2><p>限制的服务器都需要使用很多组件，库、框架等软件组件和应用有着相同权限。如果存在有漏洞的组件，那么攻击就能导致数据泄露甚至控制服务器。组件中的漏洞会导致整个应用和API安全性下降。</p>
<p>防御：</p>
<ul>
<li>移除不使用的功能组件</li>
<li>从正规渠道获取组件</li>
<li>及时更新、修复组件漏洞</li>
</ul>
<h2 id="不足的日志记录和监控"><a href="#不足的日志记录和监控" class="headerlink" title="不足的日志记录和监控"></a>不足的日志记录和监控</h2><p>日志和监控不足，再加上缺失或无效的事件响应，允许攻击者进一步攻击系统。</p>
<p>防御：</p>
<ul>
<li>启用日志监控、告警机制</li>
<li>尽可能的完整记录所有日志</li>
</ul>
<h2 id="其他常见web漏洞"><a href="#其他常见web漏洞" class="headerlink" title="其他常见web漏洞"></a>其他常见web漏洞</h2><hr>
<h2 id="CSRF跨站请求伪造"><a href="#CSRF跨站请求伪造" class="headerlink" title="CSRF跨站请求伪造"></a>CSRF跨站请求伪造</h2><p><img src="/../images/owasp-top10/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZW5saWppYW4=,size_16,color_FFFFFF,t_70.png"></p>
<p>简单来说就是用户拥有网站A的cookie,攻击者诱导用户点击网站B从而获得用户cookie假装为用户去访问网站A</p>
<p>防御：</p>
<ul>
<li>在请求参数中增加一个随机token</li>
<li>敏感操作使用POST以表单形式提交，避免token泄露。</li>
</ul>
<h2 id="SSRF服务器端请求伪造"><a href="#SSRF服务器端请求伪造" class="headerlink" title="SSRF服务器端请求伪造"></a>SSRF服务器端请求伪造</h2><p>SSRF是一种由攻击者构造形成由服务器端发起请求的安全的一个安全漏洞。</p>
<p>原理：服务器端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。</p>
<p>ssrf是利用存在缺陷的web应用作为代理攻击远程和本地服务器。</p>
<p>防御：</p>
<ol>
<li>过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一类型的文件，那么在返回结果展示给用户之前先验证返回是信息是否符合标准。</li>
<li>统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</li>
<li>限制请求的端口为哦HTTP常用端口，如80，8080，8090，443</li>
<li>黑名单内网IP。避免应用被用来获取内网数据，攻击内网。</li>
<li>禁止不需要的协议。</li>
</ol>
<p>参考文章：</p>
<p><a href="https://blog.csdn.net/qq_43378996/article/details/124050308">SSRF漏洞原理攻击与防御(超详细总结)-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/angry_program/article/details/107855078">目录穿越/遍历漏洞 – 学习笔记_目录遍历漏洞描述-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_32261191/article/details/101686779">常见的Web漏洞——命令注入_命令注入漏洞-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/weixin_50464560/article/details/120926097">WAF绕过思路整理(挺全)_waf绕过总结-CSDN博客</a></p>
]]></content>
      <categories>
        <category>web漏洞</category>
      </categories>
      <tags>
        <tag>常见web漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>随便看看</title>
    <url>/2024/04/14/%E9%9A%8F%E4%BE%BF%E7%9C%8B%E7%9C%8B/</url>
    <content><![CDATA[<h2 id="渗透测试流程"><a href="#渗透测试流程" class="headerlink" title="渗透测试流程"></a>渗透测试流程</h2><h2 id="给你一个网站如何进行渗透测试"><a href="#给你一个网站如何进行渗透测试" class="headerlink" title="给你一个网站如何进行渗透测试"></a>给你一个网站如何进行渗透测试</h2><p><a href="https://zhuanlan.zhihu.com/p/25605198">给你一个网站你是如何来渗透测试的? - 知乎 (zhihu.com)</a></p>
<p>漏洞扫描工具：</p>
<p><a href="https://blog.csdn.net/qq_37776764/article/details/130713025">Nessus、AWVS、Appscan、OWASP漏洞扫描工具的区别（介绍、测试对象对比、优劣对比、使用选择）_nessus和awvs区别_网络安全刚子的博客-CSDN博客</a></p>
<h2 id="linux，windows-提权手法有哪些，讲一讲"><a href="#linux，windows-提权手法有哪些，讲一讲" class="headerlink" title="linux，windows 提权手法有哪些，讲一讲"></a>linux，windows 提权手法有哪些，讲一讲</h2><p><a href="https://blog.csdn.net/lkbzhj/article/details/130182211">windows和linux常见的提权方法_BTY@BTY的博客-CSDN博客</a></p>
<p>[Windows常用提权方法 (ﾟ益ﾟメ) 渗透测试_win提权_寻_觅的博客-CSDN博客](<a href="https://blog.csdn.net/qq_39611230/article/details/114745974#:~:text=%E6%8F%90%E6%9D%83%E8%AF%B4%E6%98%8E">https://blog.csdn.net/qq_39611230/article/details/114745974#:~:text=提权说明</a>. Windows作为一个非常完善和成熟的系统体系%2C有着十分强大的权限管理体系%2C一般成熟的项目中%2C也都会有着比较完善的权限分级体系%2C我们一般能获取到的权限都是 普通用户权限或管理员权限 %2CWindows中提权主要指的就是将我们的权限提升到系统管理员 (system)权限。. 提权不仅可以利用系统漏洞进行%2C一些软件程序的缺陷也可以被利用作为提权的一种方式。. 权限等级%3A 普通用户,&lt; 管理员 (administrator或管理员组其他用户) &lt; 系统管理员%2C超级管理员 (system) windows漏洞汇总%3A https%3A%2F%2Fgithub.com%2FSecWiki%2Fwindows-kernel-exploits.)</p>
<p><a href="https://zhuanlan.zhihu.com/p/304572787">Linux 提权原理及十种提权姿势详解 - 知乎 (zhihu.com)</a></p>
<p>（选几个了解）</p>
<h2 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h2><p>在渗透测试中，经常会使用到端口转发和代理。</p>
<p>端口转发是转发一个网络端口从一个网络节点到另一个网络节点的行为。</p>
<p>端口转发和代理在渗透测试中有广泛的应用，可以帮助渗透测试人员隐藏其真实身份、绕过安全措施，并获取更多的攻击面。以下是一些常见的应用场景：</p>
<ol>
<li>隐藏真实IP地址：通过使用代理服务器，渗透测试人员可以隐藏其真实IP地址，使其活动更难被追踪或识别。</li>
<li>绕过防火墙和入侵检测系统：通过使用端口转发和代理，可以绕过目标网络中的防火墙和入侵检测系统，使得攻击者能够更轻易地访问目标系统。</li>
<li>穿越NAT和防火墙：在网络渗透测试中，目标系统可能位于NAT（网络地址转换）或防火墙后面，使得直接访问变得困难。使用端口转发和代理可以帮助渗透测试人员建立起与目标系统之间的通信通道。</li>
<li>数据流量转发和中继：渗透测试人员可以使用端口转发和代理来转发和中继数据流量，以便在攻击过程中传递恶意代码、执行命令或获取敏感数据。</li>
<li>模拟攻击：通过使用代理服务器，渗透测试人员可以模拟攻击者的行为，例如使用匿名代理服务器发送恶意请求、执行暴力破解等操作，以评估目标系统的安全性和弱点。</li>
</ol>
<p><a href="https://zhuanlan.zhihu.com/p/46804075">渗透基础——端口转发与代理 - 知乎 (zhihu.com)</a></p>
<p><a href="https://www.freebuf.com/articles/web/170970.html">内网渗透之端口转发与代理工具总结 - FreeBuf网络安全行业门户</a></p>
<p>常用工具有lcx(端口转发)</p>
<p>nc反弹，proxychains</p>
<h2 id="打点一般会用什么漏洞"><a href="#打点一般会用什么漏洞" class="headerlink" title="打点一般会用什么漏洞"></a>打点一般会用什么漏洞</h2><p>打点（Foothold）是指获取对目标系统的初始访问权限或建立初始的控制点。</p>
<h2 id="擅长-web-还是内网"><a href="#擅长-web-还是内网" class="headerlink" title="擅长 web 还是内网"></a>擅长 web 还是内网</h2><h2 id="被拿-shell-了如何处理"><a href="#被拿-shell-了如何处理" class="headerlink" title="被拿 shell 了如何处理"></a>被拿 shell 了如何处理</h2><p>PDCERF 模型，简答<strong>排查、清除、看看可有即使修复的可能，不得已就关站</strong></p>
<p>Prepare（准备）：准备用来检测的工具和人</p>
<p>Detection（检测）：紧急事件监测：包括防火墙、系统、web 服务器、IDS/WAF/SIEM 中的日志，不正常或者是执行了越权操作的用户，甚至还有管理员的报告</p>
<p>Containment（抑制）：首先先控制受害范围，不要让攻击的影响继续蔓延到其他的 IT 资产和业务环境，切记不要直接一股脑的投入全部精力到封堵后门。紧接着要做的是去寻找根源原因，彻底解决，封堵攻击源，把业务恢复到更张水平</p>
<p>Eradication（根除）</p>
<p>Recover（恢复）</p>
<p>Follow-Up（跟踪）：根据各种监控去确定没有其他的攻击行为和攻击向量，紧接着就是开会反省此次事件，写报告，持续改进工作流程和工作缓解</p>
<h2 id="设备出现了误报如何处置（日志）"><a href="#设备出现了误报如何处置（日志）" class="headerlink" title="设备出现了误报如何处置（日志）"></a>设备出现了误报如何处置（日志）</h2><p>答：要确认设备是否误报，应当先去查看设备的完整流量日志等信息。在护网过程中如果确实存在异常流量应当及时进行上报，确认是误报后做好事件记录。</p>
<h2 id="如何查看区分是扫描流量和手动流量"><a href="#如何查看区分是扫描流量和手动流量" class="headerlink" title="如何查看区分是扫描流量和手动流量"></a>如何查看区分是扫描流量和手动流量</h2><p>答：扫描的数据量大，请求流量有规律可寻，手动流量请求少 间隔略长</p>
<h2 id="拿到一台域内的主机之后，怎么进行域渗透"><a href="#拿到一台域内的主机之后，怎么进行域渗透" class="headerlink" title="拿到一台域内的主机之后，怎么进行域渗透"></a>拿到一台域内的主机之后，怎么进行域渗透</h2><p><a href="https://www.freebuf.com/company-information/172630.html">干货！内网渗透测试之域渗透详解！收藏！ - FreeBuf网络安全行业门户</a></p>
<p><a href="https://blog.csdn.net/q20010619/article/details/121588113">内网渗透-完整的域渗透_OceanSec的博客-CSDN博客</a></p>
<p>msf工具多了解了解</p>
<h2 id="内网的-IP-地址有哪些"><a href="#内网的-IP-地址有哪些" class="headerlink" title="内网的 IP 地址有哪些"></a>内网的 IP 地址有哪些</h2><p>常见的内网IP段有：</p>
<p>10.0.0.0/8<br>10.0.0.0 - 10.255.255.255<br>172.16.0.0/12<br>172.16.0.0 - 172.31.255.255<br>192.168.0.0/16<br>192.168.0.0 - 192.168.255.255<br>以上三个网段分别属于A、B、C三类IP地址</p>
<h2 id="如果让你写个工具，思路是什么-或者别人工具的实现原理"><a href="#如果让你写个工具，思路是什么-或者别人工具的实现原理" class="headerlink" title="如果让你写个工具，思路是什么(或者别人工具的实现原理)"></a>如果让你写个工具，思路是什么(或者别人工具的实现原理)</h2><p>确定需求、编程语言、设计架构、编写代码、测试和优化、发布和维护。</p>
<p><a href="https://wenku.baidu.com/view/6928c01ba16925c52cc58bd63186bceb19e8edac.html?_wkts_=1694418257701">安全工具编写思路 - 百度文库 (baidu.com)</a></p>
<p>sqlmap工具原理：</p>
<ol>
<li>参数识别：SQLMap会分析目标URL，并识别出可能存在SQL注入的参数。它会检查GET和POST请求中的参数，并尝试注入恶意的SQL语句。</li>
<li>注入检测：SQLMap使用各种注入技术和测试向量来检测目标应用程序的SQL注入漏洞。它会向目标应用程序发送特定的注入字符串，并观察返回的响应，以确定是否存在注入漏洞。</li>
<li>注入漏洞利用：一旦SQLMap确认目标应用程序存在注入漏洞，它会尝试利用该漏洞来执行进一步的操作。这包括获取数据库的信息、提取敏感数据、绕过身份验证、执行系统命令等。</li>
<li>基于启发式的攻击：SQLMap使用一系列启发式技术来自动选择合适的注入技术和测试向量。它会根据目标应用程序的响应和特征来调整注入策略，并尝试多个注入点以获取最佳结果。</li>
<li>漏洞报告和输出：SQLMap会生成详细的报告，列出发现的注入漏洞、提取的数据和执行的操作。这些报告可以帮助用户了解目标应用程序的安全状况，并提供进一步的分析和建议</li>
</ol>
<h2 id="后面的发展规划-学习方向"><a href="#后面的发展规划-学习方向" class="headerlink" title="后面的发展规划(学习方向)"></a>后面的发展规划(学习方向)</h2><ol>
<li><p>深入研究网络和系统安全：学习网络和系统的底层工作原理，包括网络协议、操作系统、网络架构等。深入了解攻击技术和防御机制，包括网络攻击、漏洞利用、入侵检测与防御等。</p>
</li>
<li><p>研究漏洞分析和渗透测试：学习漏洞分析的方法和技术，了解常见的软件漏洞类型和利用方式。通过渗透测试来评估网络和应用程序的安全性，并提供修复建议。</p>
</li>
<li><p>学习人工智能和机器学习在安全中的应用：人工智能和机器学习在安全领域具有广泛的应用，包括威胁检测、异常行为分析、网络流量分析等。了解机器学习算法和数据分析技术，并应用于网络安全的相关领域。</p>
</li>
<li><p>深入了解法律和合规要求：学习与网络安全相关的法律法规和合规要求，包括数据保护法、隐私法、网络安全法等。了解合规框架和审计标准，并能够帮助组织遵守相关法规。</p>
</li>
<li><p>持续学习和跟踪最新趋势：网络安全领域发展迅速，新的威胁和技术不断涌现。参与安全社区、参加安全会议和培训，持续学习并跟踪最新的趋势和技术。</p>
</li>
<li><p>考虑获取相关认证：网络安全领域有许多行业认可的安全认证，如CISSP、NISP等。</p>
<p>主要是多动手实践。</p>
</li>
</ol>
<h2 id="常见的-SQL-注入类型有哪些？并写出-sqlmap-检测-SQL-注入的命令？SQLMAPAPI"><a href="#常见的-SQL-注入类型有哪些？并写出-sqlmap-检测-SQL-注入的命令？SQLMAPAPI" class="headerlink" title="常见的 SQL 注入类型有哪些？并写出 sqlmap 检测 SQL 注入的命令？SQLMAPAPI"></a>常见的 SQL 注入类型有哪些？并写出 sqlmap 检测 SQL 注入的命令？SQLMAPAPI</h2><p><a href="https://www.freebuf.com/articles/web/256532.html">初学SQL注入之常见的几种注入类型介绍 - FreeBuf网络安全行业门户</a></p>
<ol>
<li>扫描目标URL：sqlmap -u &lt;目标URL&gt;</li>
<li>扫描目标URL并检测注入：sqlmap -u &lt;目标URL&gt; –dbs</li>
<li>指定注入参数进行测试：sqlmap -u &lt;目标URL&gt; -p &lt;注入参数&gt;</li>
<li>指定数据库类型进行测试：sqlmap -u &lt;目标URL&gt; –dbms &lt;数据库类型&gt;</li>
<li>使用Cookie进行测试：sqlmap -u &lt;目标URL&gt; –cookie “&lt;Cookie数据&gt;”</li>
<li>执行具体的SQL注入攻击：sqlmap -u &lt;目标URL&gt; –data “&lt;POST数据&gt;” –method POST –level 5 –risk 3</li>
</ol>
<p>SQLMapAPI 是 SQLMap 工具的一个组件，SQLMapAPI 提供了一组 RESTful 风格的 API，可以通过发送 HTTP 请求与 SQLMap 进行通信。使用 SQLMapAPI，你可以编写自定义脚本或集成其他应用程序来自动化执行 SQL 注入测试和利用。</p>
<h2 id="内网如何反弹-shell，反弹的-shell-流量如何隐蔽"><a href="#内网如何反弹-shell，反弹的-shell-流量如何隐蔽" class="headerlink" title="内网如何反弹 shell，反弹的 shell 流量如何隐蔽"></a>内网如何反弹 shell，反弹的 shell 流量如何隐蔽</h2><p><a href="https://zhuanlan.zhihu.com/p/607054390">常用内网反弹shell方法一览 - 知乎 (zhihu.com)</a></p>
<p><a href="https://www.freebuf.com/articles/web/268651.html">内网渗透——反弹shell详解 - FreeBuf网络安全行业门户</a></p>
<h2 id="如何拿shell"><a href="#如何拿shell" class="headerlink" title="如何拿shell"></a>如何拿shell</h2><p><a href="https://blog.csdn.net/zdy8023/article/details/89059137">拿shell的一些方式_努力奋斗的小青年的博客-CSDN博客</a></p>
<h2 id="注入攻击原理是什么？如何找注入点？如何判断注入点？"><a href="#注入攻击原理是什么？如何找注入点？如何判断注入点？" class="headerlink" title="注入攻击原理是什么？如何找注入点？如何判断注入点？"></a>注入攻击原理是什么？如何找注入点？如何判断注入点？</h2><p>sql注入，xss，LDAP注入，命令注入了解这些。</p>
<p><a href="https://segmentfault.com/a/1190000037581113">注入攻击笔记 - 个人文章 - SegmentFault 思否</a></p>
<h2 id="owasp-top10"><a href="#owasp-top10" class="headerlink" title="owasp top10"></a>owasp top10</h2><p><a href="https://zhuanlan.zhihu.com/p/374512917">owasp top10 | 十大常见漏洞详解 - 知乎 (zhihu.com)</a></p>
<h2 id="CDn-负载均衡你知道吧-如果攻击方使用的是一个有挂了-CDn-负载均衡的服务器来攻击你，你要怎么溯源到目标的真实-IP-地址呢"><a href="#CDn-负载均衡你知道吧-如果攻击方使用的是一个有挂了-CDn-负载均衡的服务器来攻击你，你要怎么溯源到目标的真实-IP-地址呢" class="headerlink" title="CDn 负载均衡你知道吧?如果攻击方使用的是一个有挂了 CDn 负载均衡的服务器来攻击你，你要怎么溯源到目标的真实 IP 地址呢?"></a>CDn 负载均衡你知道吧?如果攻击方使用的是一个有挂了 CDn 负载均衡的服务器来攻击你，你要怎么溯源到目标的真实 IP 地址呢?</h2><p>CDN： 是构建在数据网络上的一种分布式的内容分发网。 可以提高系统的响应速度，也可以一定程度的拦截/防御攻击。</p>
<p>多地ping，反向攻击代理拿下服务器然后日志审计</p>
<p><a href="https://zhuanlan.zhihu.com/p/589622686%EF%BC%88%E5%A4%9A%E5%9C%B0Ping">https://zhuanlan.zhihu.com/p/589622686（多地Ping</a>)</p>
<h2 id="和甲方上报-IP-地址，你要上报哪些地址呢"><a href="#和甲方上报-IP-地址，你要上报哪些地址呢" class="headerlink" title="和甲方上报 IP 地址，你要上报哪些地址呢?"></a>和甲方上报 IP 地址，你要上报哪些地址呢?</h2><p>上报攻击 ip 的地址，先判断是内网 ip 还是公网 ip，如果是内网ip，查看是否是业务白名单行为，若不是再上报进行判断。若是公网 ip，查看是否在白名单内，若不是查看是否是扫描器 ip，若是扫描器 ip，扫描对业务或者对研判产生了影响则可以上报，若不是且判断出是真实攻击 ip 也进行上报。</p>
<h2 id="如果看到一个告警ip，如何判断是否是真实攻击？"><a href="#如果看到一个告警ip，如何判断是否是真实攻击？" class="headerlink" title="如果看到一个告警ip，如何判断是否是真实攻击？"></a>如果看到一个告警ip，如何判断是否是真实攻击？</h2><p>首先，我会先判断一下ip来源，判断是内网ip还是公网ip，若为内网ip，然后对请求包的内容是否存在恶意payload，然后再根据响应包内容有执行成功的回显，若相应包中有对应的payload的回显，则可以判断为攻击成功，但是此时，需要判断下是否为业务系统的逻辑造成的和是否是工作人员在测试业务系统漏洞，若工作人员证实了该告警为自家安全ip，则认为该攻击为误报，若非自家ip且不存在逻辑因素，则可判断为内网攻陷。若为公网ip，若恶意payload利用成功，则可判断为真实攻击。</p>
<h2 id="三握手四挥手"><a href="#三握手四挥手" class="headerlink" title="三握手四挥手"></a>三握手四挥手</h2><h3 id="三握手："><a href="#三握手：" class="headerlink" title="三握手："></a>三握手：</h3><p>第一次：客户端将tcp报文的标志位SYN设置为1，随机产生一个序号值seq=j，保存在TCP首部的序列号字段里面，指明客户端想要连接的服务器端口，把该数据包发送给服务器。客服端进入SYN_SENT状态。</p>
<p>第二次：服务器端收到数据包后根据标志位SYN=1知道客服端请求建立连接，服务器端将TCP报文标志位SYN和ACK都设置为1，并且令头部确认号（Acknowledge number， 缩写ack）为j+1，（ack=seq+1），随机产生seq=k,把该数据包发送给客户端以确认连接请求。服务器端进入SYN_RCVD状态。</p>
<p>第三次:客户端收到确认检查ack，是否=j+1，ACK是否为一，如果正确将ACK标志设置为1.ack=k+1，把该数据包发送给服务器端，服务器端检查ACK是否=1，ack是否为k+1，正确则建立成功。双方进入establised状态（已建立态）</p>
<h3 id="四挥手："><a href="#四挥手：" class="headerlink" title="四挥手："></a>四挥手：</h3><p>三握手属于建立连接，四挥手属于关闭连接，</p>
<p>第一次:客户端发起挥手请求向服务器端发送标志位是FIN的报文段，设置seq。客户端进入FIN_WAIT_1态</p>
<p>第二次：服务器端收到报文向客户端发送标志位是ACK的报文段，ack为seq+1。客户端进入FIN_WAIT_2态</p>
<p>第三次:服务器端向客户端发送FIN报文段，请求关闭连接。服务器端进入LAST_ACK状态。</p>
<p>第四次:客户端收到服务器端发送的FIN报文后，发一个ACK应答，ack=seq+1。</p>
<p>等待2个MSL（报文段最大生存时间）关闭连接，为什么不直接关闭，因为要确保ACK报文发到服务器端。</p>
<p><a href="https://www.cnblogs.com/zzjdbk/p/13028290.html">三次握手和四次挥手（面试必问） - My_Dreams - 博客园 (cnblogs.com)</a></p>
<h2 id="挖过哪些洞-追问原理"><a href="#挖过哪些洞-追问原理" class="headerlink" title="挖过哪些洞?追问原理"></a>挖过哪些洞?追问原理</h2><h2 id="挖过最有意思-最难的一个洞"><a href="#挖过最有意思-最难的一个洞" class="headerlink" title="挖过最有意思/最难的一个洞"></a>挖过最有意思/最难的一个洞</h2><p>威努特<br>中国化学工程第七建设有限公司<br>长虹集团<br>大华股份2024届全球校园招聘正式启动！<br>成都安恒信息技术有限公司<br>赛力斯集团20<br>天奥电子2024届校园招聘<br>迈普通信技术股份<br>成都创信华通信息技术有限公司<br>深信服24届全球校园招聘正式启动！<br>北京人大金仓2024校园招聘全面启动！<br>成都拓尔思信息技术有限公司<br>中国建筑装饰集团校园招聘简章</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面面</tag>
      </tags>
  </entry>
  <entry>
    <title>售前技术支持</title>
    <url>/2024/04/21/%E5%94%AE%E5%89%8D%E6%8A%80%E6%9C%AF%E6%94%AF%E6%8C%81/</url>
    <content><![CDATA[<ol>
<li>自我介绍</li>
<li>大学里你最喜欢的两门专业课</li>
<li>你了解网络安全吗？</li>
<li>网络安全和网络空间安全有什么区别</li>
<li>你对这个岗位的理解？你有什么优势？过往你觉得最匹配的经历是什么？</li>
<li>最有成就感的事情</li>
<li>你觉得你抗压能力很强吗？举个例子</li>
<li>反问：对同学的期望（学习能力、开心、抗压、做自己保持特点和竞争力</li>
<li></li>
<li></li>
<li>最喜欢的专业课围绕上面说的专业课提问老问题了基本，OSI7层，TCP/IP，TCPUDP区别，TCP长/短连接</li>
<li>为什么选售前，你的优势是什么。</li>
<li>问在的学校干部经历，怎么当的干部，做了些啥。</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面面</tag>
      </tags>
  </entry>
  <entry>
    <title>技术支持</title>
    <url>/2024/04/21/%E6%8A%80%E6%9C%AF%E6%94%AF%E6%8C%81/</url>
    <content><![CDATA[<p>1）主机A和主机B在网络上通信，具体要经过哪些过程，中间又涉及到了哪几层网络模型和协议。<br>主机A和主机B在网络上通信的过程通常经过以下步骤：</p>
<ol>
<li><strong>应用层</strong>：<ul>
<li>应用层是通信的起点，主机A的应用程序（如Web浏览器）需要向主机B的应用程序（如Web服务器）发送请求或获取数据。这个过程涉及到应用层协议，如HTTP、FTP等。</li>
</ul>
</li>
<li><strong>传输层</strong>：<ul>
<li>应用层数据被传递到传输层，通常使用TCP或UDP协议。如果采用TCP协议，会进行可靠的数据传输，包括握手、数据传输和挥手；如果采用UDP协议，则会直接传输数据，不保证可靠性。</li>
</ul>
</li>
<li><strong>网络层</strong>：<ul>
<li>传输层的数据被传递到网络层，网络层负责将数据从源主机传输到目标主机。在网络层，数据被封装为数据包，并通过IP协议进行路由选择和传输。</li>
</ul>
</li>
<li><strong>数据链路层</strong>：<ul>
<li>网络层的数据包被传递到数据链路层，数据链路层负责在相邻节点之间传输数据。在数据链路层，数据被封装为帧，并通过MAC地址进行传输。</li>
</ul>
</li>
<li><strong>物理层</strong>：<ul>
<li>数据链路层的帧通过物理层进行传输，物理层负责在物理介质上传输比特流。这可能涉及到光纤、电缆、无线电波等物理媒介。</li>
</ul>
</li>
<li><strong>目标主机解封装和处理</strong>：<ul>
<li>当数据到达目标主机后，数据被逐层解封装并传递给目标主机的应用层。目标主机的应用程序根据需要处理数据，并进行相应的响应或处理。</li>
</ul>
</li>
</ol>
<p>在整个通信过程中，数据经过了应用层、传输层、网络层、数据链路层和物理层五层模型的处理。其中，应用层负责定义通信的规则和协议，传输层负责端到端的数据传输，网络层负责网络间的数据传输，数据链路层负责相邻节点之间的数据传输，物理层负责物理介质上的数据传输。</p>
<p>2）讲讲TCP协议簇的工作原理及拥塞控制原理。</p>
<ol>
<li><strong>立连接</strong>：通信双方需要先建立连接，这是通过三次握手来完成的。客户端发送SYN报文，服务端回应SYN+ACK报文，最后客户端发送ACK报文确认连接建立。</li>
<li><strong>数据传输</strong>：连接建立后，数据可以在通信双方之间传输。发送方将数据切分为适当大小的数据段，并添加序号和确认号等控制信息。接收方接收数据，并发送确认信息。</li>
<li><strong>连接终止</strong>：通信结束后，需要关闭连接。这是通过四次挥手来完成的。发送方发送FIN报文，接收方回应ACK报文确认，然后发送FIN报文，最后发送方回应ACK报文确认。</li>
</ol>
<h3 id="拥塞控制原理："><a href="#拥塞控制原理：" class="headerlink" title="拥塞控制原理："></a>拥塞控制原理：</h3><p>TCP的拥塞控制旨在避免网络拥塞并维持网络的稳定性，主要包括以下几个方面：</p>
<ol>
<li><strong>慢启动（Slow Start）</strong>：连接刚建立时，TCP发送方先将拥塞窗口设置为一个较小的值，然后随着时间的推移逐渐增大。这样可以防止一开始就发送大量数据导致网络拥塞。</li>
<li><strong>拥塞避免（Congestion Avoidance）</strong>：一旦拥塞窗口大小达到一定阈值，TCP发送方将采用线性增加的方式增大拥塞窗口，以更稳健的方式发送数据。</li>
<li><strong>快速重传（Fast Retransmit）</strong>：当发送方连续收到三个重复的确认报文时，它会认为有数据包丢失，立即重传丢失的数据包，而不是等待超时时间。</li>
<li><strong>拥塞超时（Timeout）</strong>：如果发送方在一定时间内没有收到对特定数据段的确认，它会认为数据丢失，触发拥塞控制机制，重新发送丢失的数据包。</li>
<li><strong>拥塞窗口减小（Congestion Window Reduction）</strong>：当发生丢包时，TCP发送方会将拥塞窗口减小一定比例，以缓解网络拥塞并防止进一步丢包。</li>
</ol>
<p>3）讲讲DHCP协议内容。</p>
<p>DHCP（Dynamic Host Configuration Protocol）是一种用于动态分配IP地址和其他网络配置信息的网络协议。它允许网络中的设备在连接到网络时自动获取IP地址、子网掩码、默认网关、DNS服务器等网络配置信息，而无需管理员手动配置。</p>
<p>4）以前用过linux系统吗?知道哪些linux命令?具体举个例子说明。</p>
<pre class="language-none"><code class="language-none">ls：列出当前目录下的文件和子目录。
示例：ls
cd：切换工作目录。
示例：cd /path/to/directory
pwd：显示当前工作目录的路径。
示例：pwd
mkdir：创建新目录。
示例：mkdir new_directory
rm：删除文件或目录。
示例：rm filename 或 rm -r directory
cp：复制文件或目录。
示例：cp source_file destination_file 或 cp -r source_directory destination_directory
mv：移动文件或目录，或重命名文件。
示例：mv source destination 或 mv old_name new_name
cat：查看文件内容。
示例：cat filename
more 或 less：逐页查看文件内容。
示例：more filename 或 less filename
grep：在文件中搜索指定的文本模式。
示例：grep pattern filename
chmod：修改文件或目录的权限。
示例：chmod permissions filename
chown：修改文件或目录的所有者。
示例：chown owner:group filename
ps：显示系统中正在运行的进程。
示例：ps aux
kill：终止指定的进程。
示例：kill process_id
top：实时显示系统中运行的进程。
示例：top
df：显示磁盘空间使用情况。
示例：df -h
du：显示指定目录或文件的磁盘使用情况。
示例：du -h directory
wget：从网络上下载文件。
示例：wget URL
tar：用于打包和解压文件。
示例：tar -zvxf xxxx.tar 
ssh：通过安全的shell协议登录到远程主机。
示例：ssh username@hostname</code></pre>

<p>5）讲讲网页请求服务器数据的过程，网络通信是怎么运作的。</p>
<p>网页请求服务器数据的过程涉及多个步骤，网络通信通过分层协议栈实现</p>
<p>1.HTTP协议（超文本传输协议）</p>
<p>HTTP协议通常用于客户端和服务器之间的通信，客户端发送HTTP请求给服务器，服务器响应HTTP响应给客户端。</p>
<p>2版本控制工具(git)，迁代码用什么命令</p>
<p>3网络七层模型讲一下</p>
<p>5 TCP，HTTP工作在哪一层</p>
<p>传输层，应用层</p>
<p>6TCP怎么保证可靠性</p>
<p><strong>序列号与确认应答</strong></p>
<p><strong>超时重传机制</strong></p>
<p><strong>拥塞控制机制</strong></p>
<p>7ARP协议知道吗</p>
<p>ARP，即地址解析协议（Address Resolution Protocol），是一种用于将IP地址转换为物理MAC地址的协议。</p>
<p>8免费ARP报文干什么用的</p>
<p>免费ARP报文是ARP协议的一种应用，它帮助确保网络中的所有主机都具有最新的IP地址到MAC地址的映射关系，从而确保网络通信的正确性和可靠性。</p>
<p>9 socket编程</p>
<ol>
<li><p><strong>创建Socket</strong>：首先，程序需要创建一个Socket对象，用于表示网络连接。在大多数编程语言中，可以使用内置的Socket库或模块来创建Socket对象。</p>
</li>
<li><p><strong>绑定地址和端口</strong>：如果程序是服务器端，它需要绑定一个IP地址和端口号，以便客户端能够连接到它。如果是客户端，通常不需要绑定地址和端口。</p>
</li>
<li><p><strong>监听连接</strong>（仅服务器端）：服务器端需要监听来自客户端的连接请求。它会在指定的端口上监听，等待客户端的连接。</p>
</li>
<li><p><strong>接受连接</strong>（仅服务器端）：一旦有客户端连接请求到达，服务器端会接受连接，并创建一个新的Socket对象来处理与该客户端的通信。</p>
</li>
<li><p><strong>连接服务器</strong>（仅客户端）：客户端需要连接到服务器。它会指定服务器的IP地址和端口号，并尝试建立连接。</p>
</li>
<li><p><strong>发送和接收数据</strong>：一旦建立连接，双方就可以通过Socket对象发送和接收数据。数据可以是文本、二进制数据等。</p>
</li>
<li><p><strong>关闭连接</strong>：通信完成后，双方可以关闭连接，释放资源。</p>
</li>
</ol>
<p>10 TCP协议客户端和服务器端建立连接和断开连接的交互过程</p>
<p>三握手，四挥手</p>
<p>11 MAC地址的位数</p>
<p>48位二进制，以8个16进制对来表示</p>
<p>12 OSI7层，TCP/IP，TCP UDP区别，TCP长/短连接</p>
<h3 id="TCP与UDP区别："><a href="#TCP与UDP区别：" class="headerlink" title="TCP与UDP区别："></a>TCP与UDP区别：</h3><ol>
<li><p><strong>可靠性</strong>：</p>
<ul>
<li>TCP是一种面向连接的协议，提供可靠的数据传输，通过确认应答、重传机制等确保数据的完整性和顺序性。</li>
<li>UDP是一种无连接的协议，不提供数据传输的可靠性保证，数据可能会丢失或乱序。</li>
</ul>
</li>
<li><p><strong>流量控制</strong>：</p>
<ul>
<li>TCP具有流量控制机制，根据接收方的处理能力调整发送速率，防止数据拥塞。</li>
<li>UDP不具备流量控制机制，发送方会以固定的速率发送数据，不考虑网络拥塞情况。</li>
</ul>
</li>
<li><p><strong>连接状态</strong>：</p>
<ul>
<li>TCP是面向连接的，需要在通信双方建立连接后才能传输数据，并且保持连接状态直到通信结束。</li>
<li>UDP是无连接的，通信双方之间没有建立连接的过程，每个数据包都是独立的。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>：</p>
<ul>
<li>TCP适用于对数据传输可靠性要求较高的场景，如文件传输、网页访问、电子邮件等。</li>
<li>UDP适用于对数据传输实时性要求较高的场景，如音视频流媒体、在线游戏等。</li>
</ul>
</li>
<li><h3 id="TCP长连接和短连接："><a href="#TCP长连接和短连接：" class="headerlink" title="TCP长连接和短连接："></a>TCP长连接和短连接：</h3><ol>
<li><strong>长连接</strong>：<ul>
<li>长连接是指客户端和服务器之间建立一次连接后，在一定时间内保持连接状态，可以进行多次数据传输。</li>
<li>长连接适用于客户端和服务器之间有频繁的数据交互，可以减少建立连接和断开连接的开销，提高效率。</li>
</ul>
</li>
<li><strong>短连接</strong>：<ul>
<li>短连接是指客户端和服务器之间每次数据传输都建立一个新的连接，传输完成后立即断开连接。</li>
<li>短连接适用于一次性数据传输，或者客户端和服务器之间的交互较为分散的场景，不需要保持连接状态。</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>13TCP/IP在哪层</p>
<p>15 git的相关命令</p>
<p><strong>git init</strong>: 初始化一个新的本地仓库。</p>
<p><strong>git clone <repository_url></repository_url></strong>: 从远程仓库克隆代码到本地。</p>
<p><strong>git add <file_name></file_name></strong>: 将文件添加到暂存区。</p>
<p><strong>git commit -m “Commit message”</strong>: 提交暂存区中的文件并添加提交消息。</p>
<p><strong>git status</strong>: 显示工作区和暂存区的状态。</p>
<p><strong>git diff</strong>: 显示工作区和暂存区之间的差异。</p>
<p><strong>git log</strong>: 显示提交日志。</p>
<p><strong>git push origin <branch_name></branch_name></strong>: 将本地分支推送到远程仓库。</p>
<p><strong>git pull origin <branch_name></branch_name></strong>: 从远程仓库拉取更新到本地分支。</p>
<p><strong>git branch</strong>: 列出本地分支。</p>
<p><strong>git checkout -b <branch_name></branch_name></strong>: 创建并切换到新分支。</p>
<p><strong>git checkout <branch_name></branch_name></strong>: 切换到指定分支。</p>
<p><strong>git merge <branch_name></branch_name></strong>: 将指定分支合并到当前分支。</p>
<p><strong>git remote -v</strong>: 显示远程仓库信息。</p>
<p><strong>git stash</strong>: 将当前工作区的改动保存到栈中，以便稍后恢复。</p>
<p>16学过数据结构吗，那说说看</p>
<p>三要素：逻辑结构，存储结构，数据运算，常见有数组，队列，栈，树，哈希表，堆，图，链表。</p>
<p>17数据库操作了解什么</p>
<ol>
<li><strong>创建数据库</strong>：</li>
</ol>
<pre class="language-none"><code class="language-none">CREATE DATABASE database_name;</code></pre>

<ol>
<li><strong>选择数据库</strong>：</li>
</ol>
<pre class="language-none"><code class="language-none">USE database_name;</code></pre>

<ol>
<li><strong>创建表</strong>：</li>
</ol>
<pre class="language-none"><code class="language-none">CREATE TABLE table_name (
    column1 datatype,
    column2 datatype,
    ...
);</code></pre>

<ol>
<li><strong>插入数据</strong>：</li>
</ol>
<pre class="language-none"><code class="language-none">INSERT INTO table_name (column1, column2, ...)
VALUES (value1, value2, ...);</code></pre>

<ol>
<li><strong>查询数据</strong>：</li>
</ol>
<pre class="language-none"><code class="language-none">SELECT column1, column2, ...
FROM table_name
WHERE condition;</code></pre>

<ol>
<li><strong>更新数据</strong>：</li>
</ol>
<pre class="language-none"><code class="language-none">UPDATE table_name
SET column1 = value1, column2 = value2, ...
WHERE condition;</code></pre>

<ol>
<li><strong>删除数据</strong>：</li>
</ol>
<pre class="language-none"><code class="language-none">DELETE FROM table_name
WHERE condition;</code></pre>



<p>常用端口及对应服务<br>21：FTP服务所开放的端口，用于上传、下载文件。<br>22：SSH端口，用于通过命令行模式远程连接Linux服务器或vps。<br>23：Telnet端口，用于Telnet远程登录服务器。<br>25：SMTP服务所开放的端口，用于发送邮件。<br>80：HTTP用于HTTP服务提供访问功能，例如，IIS、Apache、Nginx 等服务。<br>110：POP3用于POP3 协议，POP3 是电子邮件收发的协议。<br>143：IMAP用于IMAP（Internet Message Access Protocol）协议，IMAP 是用于电子邮件的接收的协议。<br>443：HTTPS 用于HTTPS服务提供访问功能。HTTPS 是一种能提供加密和通过安全端口传输的一种协议。<br>1433：SQL Server SQL Server的TCP 端口，用于供SQL Server对外提供服务。<br>1434：SQL Server SQL Server的UDP端口，用于返回SQL Server使用了哪个 TCP/IP 端口。<br>1521：Oracle通信端口，服务器上部署了Oracle SQL需要放行的端口。<br>3306：MySQL数据库对外提供服务的端口。<br>3389：远程桌面服务端口，可以通过这个端口远程连接服务器。<br>8080：代理端口,同80端口一样，8080 端口常用于WWW代理服务，实现网页浏览。</p>
<p>ospf rip协议</p>
<p><a href="https://zhuanlan.zhihu.com/p/605667261">搞清RIP和OSPF的区别，这是我见过最好的总结！ - 知乎 (zhihu.com)</a></p>
<h2 id="三握手四挥手"><a href="#三握手四挥手" class="headerlink" title="三握手四挥手"></a>三握手四挥手</h2><h3 id="三握手："><a href="#三握手：" class="headerlink" title="三握手："></a>三握手：</h3><p>第一次：客户端将tcp报文的标志位SYN设置为1，随机产生一个序号值seq=j，保存在TCP首部的序列号字段里面，指明客户端想要连接的服务器端口，把该数据包发送给服务器。客服端进入SYN_SENT状态。</p>
<p>第二次：服务器端收到数据包后根据标志位SYN=1知道客服端请求建立连接，服务器端将TCP报文标志位SYN和ACK都设置为1，并且令头部确认号（Acknowledge number， 缩写ack）为j+1，（ack=seq+1），随机产生seq=k,把该数据包发送给客户端以确认连接请求。服务器端进入SYN_RCVD状态。</p>
<p>第三次:客户端收到确认检查ack，是否=j+1，ACK是否为一，如果正确将ACK标志设置为1.ack=k+1，把该数据包发送给服务器端，服务器端检查ACK是否=1，ack是否为k+1，正确则建立成功。双方进入establised状态（已建立态）</p>
<h3 id="四挥手："><a href="#四挥手：" class="headerlink" title="四挥手："></a>四挥手：</h3><p>三握手属于建立连接，四挥手属于关闭连接，</p>
<p>第一次:客户端发起挥手请求向服务器端发送标志位是FIN的报文段，设置seq。客户端进入FIN_WAIT_1态</p>
<p>第二次：服务器端收到报文向客户端发送标志位是ACK的报文段，ack为seq+1。客户端进入FIN_WAIT_2态</p>
<p>第三次:服务器端向客户端发送FIN报文段，请求关闭连接。服务器端进入LAST_ACK状态。</p>
<p>第四次:客户端收到服务器端发送的FIN报文后，发一个ACK应答，ack=seq+1。</p>
<p>等待2个MSL（报文段最大生存时间）关闭连接，为什么不直接关闭，因为要确保ACK报文发到服务器端。</p>
<p><img src="D:/source/images/技术支持/image-20240410210415227.png" alt="image-20240410210415227"></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面面</tag>
      </tags>
  </entry>
  <entry>
    <title>技术运维</title>
    <url>/2024/04/21/%E6%8A%80%E6%9C%AF%E8%BF%90%E7%BB%B4/</url>
    <content><![CDATA[<ol>
<li><p><strong>理解技术运维工程师这个岗位</strong>： 技术运维工程师负责管理和维护企业的技术基础设施，包括服务器、网络设备、数据库、操作系统等。他们负责确保系统的高可用性、性能和安全性，同时处理日常的故障排除、监控和自动化任务。这个岗位需要掌握各种技术工具和技能，包括操作系统管理、网络管理、脚本编程、自动化工具等。</p>
</li>
<li><p><strong>对微内核的理解</strong>： 微内核是一种操作系统设计架构，将核心的基本功能和服务尽可能地精简，将其它功能移动到用户空间。微内核包含了一组最基本的功能，例如进程管理、内存管理和通信机制，而其他功能则通过模块化的方式在用户空间实现。这种设计架构可以提高系统的可靠性和可扩展性。</p>
</li>
<li><p><strong>毕业设计项目的背景和解决了什么问题</strong>： 毕业设计项目的背景可能是针对某个具体的问题或需求，例如提高某个系统的性能、优化某个算法、开发某个新的软件功能等。解决了这个问题之后，项目可能会提供一个实用的解决方案或工具，从而为用户带来实际的价值。</p>
</li>
<li><p><strong>需要学习其他技术吗</strong>： 需要根据具体的项目需求和个人发展方向来确定是否需要学习其他技术。一般来说，作为技术运维工程师，学习 Linux 操作系统、网络管理、自动化工具和脚本编程等技术是非常重要的。</p>
</li>
<li><p><strong>关于 Linux 操作系统和性能监控的技术</strong>： Linux 操作系统是一种开源的 Unix-like 操作系统，广泛应用于服务器和嵌入式设备领域。性能监控技术包括监视系统资源使用情况、性能指标和日志，以便及时发现和解决系统性能问题。Python 可以用于编写自动化脚本和工具，帮助简化运维任务。</p>
</li>
<li><p><strong>关于操作系统的问题</strong>： 了解操作系统的基本概念、结构和功能是非常重要的。例如，了解进程和线程的区别和联系、如何杀死一个进程、如何查看操作系统日志、操作系统的结构等。</p>
</li>
<li><p><strong>关于服务器和项目部署的问题</strong>： 熟悉服务器管理和项目部署是技术运维工程师的重要技能。了解 Docker 等容器化技术可以帮助简化项目部署和管理任务。</p>
</li>
<li><p><strong>关于 MySQL 数据库的问题</strong>： MySQL 是一种流行的关系型数据库管理系统，了解事务隔离级别、MVCC 机制、数据库设计和性能优化等知识是非常重要的。</p>
</li>
<li><p><strong>关于计算机体系结构的问题</strong>： 了解计算机的体系结构可以帮助理解计算机硬件的工作原理和各个组件之间的关系。包括 CPU、内存、存储设备、输入输出设备等。</p>
</li>
<li><p><strong>进程和线程的区别和联系</strong>：</p>
<ul>
<li>进程（Process）是程序的执行实例，是操作系统分配资源的基本单位。每个进程有独立的内存空间、代码和数据，可以独立执行。</li>
<li>线程（Thread）是进程内的执行单元，是操作系统调度的基本单位。一个进程可以包含多个线程，它们共享进程的内存空间和资源。</li>
<li>区别：<ul>
<li>进程之间是相互独立的，线程之间共享进程的资源。</li>
<li>进程拥有独立的地址空间，线程共享进程的地址空间。</li>
<li>创建和销毁线程比创建和销毁进程开销更小，因为线程共享了进程的资源。</li>
</ul>
</li>
<li>联系：<ul>
<li>进程内的所有线程共享进程的资源，包括内存、文件句柄等。</li>
<li>线程是进程内的执行单元，多个线程可以并发执行，提高了程序的性能和响应速度。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>如何杀死一个进程</strong>： 在 Linux 系统中，可以使用 <code>kill</code> 命令来杀死一个进程。通常使用进程的 PID（进程标识符）来指定要杀死的进程，例如：</p>
<pre class="language-none"><code class="language-none">bashCopy code
kill PID</code></pre>

<p>或者可以使用 <code>killall</code> 命令根据进程的名称来杀死进程，例如：</p>
<pre class="language-none"><code class="language-none">Copy code
killall process_name</code></pre>

<p>在 Windows 系统中，可以使用任务管理器或命令行工具如 <code>taskkill</code> 来杀死进程。</p>
</li>
<li><p><strong>如何查看操作系统日志</strong>： 在 Linux 系统中，操作系统日志通常位于 <code>/var/log</code> 目录下，常见的日志文件包括 <code>/var/log/messages</code>、<code>/var/log/syslog</code> 等。您可以使用命令行工具如 <code>cat</code>、<code>less</code> 或 <code>tail</code> 来查看日志文件的内容，例如：</p>
<pre class="language-none"><code class="language-none">bashCopy code
cat /var/log/messages</code></pre>

<p>在 Windows 系统中，可以使用事件查看器（Event Viewer）来查看系统日志。</p>
</li>
<li><p><strong>操作系统都有哪些结构</strong>： 操作系统的结构通常包括以下几个方面：</p>
<ul>
<li>内核（Kernel）：负责管理系统的资源（如 CPU、内存、设备等）和提供基本的系统调用接口。</li>
<li>进程管理：负责创建、调度和终止进程，管理进程的状态、资源和通信。</li>
<li>内存管理：负责管理系统的内存资源，包括内存分配、地址映射、页面置换等。</li>
<li>文件系统：负责管理文件和目录，提供文件访问和管理的接口。</li>
<li>设备驱动程序：负责与硬件设备交互，提供设备访问的接口。</li>
<li>用户界面：提供用户与系统交互的界面，包括命令行界面和图形用户界面等。</li>
</ul>
</li>
<li><p><strong>服务器熟悉吗？</strong> 对于服务器的熟悉程度可能因人而异。通常来说，服务器管理涉及到操作系统的配置、网络设置、安全性配置、服务部署和监控等工作。</p>
</li>
<li><p><strong>如何进行项目部署，Docker用过吗？</strong> 项目部署通常包括以下几个步骤：</p>
<ul>
<li>准备环境：包括操作系统、依赖软件和配置文件等。</li>
<li>安装依赖：安装项目所需的软件和库。</li>
<li>配置项目：配置项目的参数和设置。</li>
<li>启动项目：启动项目的服务。</li>
<li>监控项目：监控项目的运行状态，处理异常情况。 Docker 是一种容器化技术，可以将应用程序及其依赖打包为一个独立的容器，方便部署和管理。使用 Docker 可以简化项目部署的过程，提高开发和运维效率。</li>
</ul>
</li>
<li><p><strong>如何打印文件的绝对路径，说 Linux 命令</strong>： 使用 <code>realpath</code> 命令可以打印文件的绝对路径。例如：</p>
<pre class="language-none"><code class="language-none">bashCopy code
realpath filename</code></pre>

<p>这将打印出 <code>filename</code> 文件的绝对路径。</p>
</li>
<li><p><strong>如何查看服务器的内存使用情况</strong>： 使用 <code>free</code> 命令可以查看服务器的内存使用情况。例如：</p>
<pre class="language-none"><code class="language-none">bashCopy code
free -h</code></pre>

<p>这将以人类可读的方式显示内存使用情况，包括总内存、已使用内存、空闲内存等信息。</p>
</li>
<li><p><strong>Linux 有哪些监控命令，怎么用</strong>：</p>
<ul>
<li><code>top</code>：实时显示系统的 CPU、内存和进程等信息。</li>
<li><code>htop</code>：类似于 <code>top</code>，但提供了更多的交互功能和信息展示。</li>
<li><code>iotop</code>：用于监控磁盘 I/O 情况。</li>
<li><code>iftop</code>：用于监控网络流量。</li>
<li><code>sar</code>：系统性能分析工具，可用于查看历史性能数据。 使用以上命令时，可以通过命令行参数调整显示的信息和更新频率，具体使用方法可查阅各自的帮助文档。</li>
</ul>
</li>
<li><p><strong>如何读取日志文件的末尾 10 行，说命令</strong>： 使用 <code>tail</code> 命令可以读取日志文件的末尾行。例如：</p>
<pre class="language-none"><code class="language-none">bashCopy code
tail -n 10 logfile</code></pre>

<p>这将显示 <code>logfile</code> 文件的末尾 10 行内容。</p>
</li>
<li><p><strong><code>sed</code> 命令用过吗？有什么作用？如何查看文件的指定行数的内容？</strong>： <code>sed</code> 是一个流编辑器，用于对文本进行编辑和转换。它可以执行插入、删除、替换等操作。要查看文件的指定行数的内容，可以使用 <code>sed</code> 命令配合行号进行操作。例如，要查看文件的第 5 行内容：</p>
<pre class="language-none"><code class="language-none">bashCopy code
sed -n '5p' filename</code></pre>

<p>这将打印出 <code>filename</code> 文件的第 5 行内容。</p>
</li>
</ol>
<p>面试官二问:</p>
<ol start="14">
<li><strong>MySQL熟悉吗？</strong> 是的，我对 MySQL 数据库比较熟悉。MySQL 是一种流行的关系型数据库管理系统，常用于存储和管理大规模的数据。我熟悉 MySQL 的基本概念、SQL 查询语言、数据库设计和优化等方面。</li>
<li><strong>说一下事务隔离级别，InnoDB默认是哪种隔离级别？</strong> 事务隔离级别是数据库管理系统定义的一种规范，用于控制事务之间的可见性和并发性。MySQL 提供了四种事务隔离级别，分别是 READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。InnoDB 存储引擎的默认隔离级别是 REPEATABLE READ（可重复读）。</li>
<li><strong>MVCC机制讲一下</strong> MVCC（Multi-Version Concurrency Control）是一种数据库并发控制机制，常见于支持事务的数据库管理系统中。它通过在数据库中维护多个数据版本来实现并发控制，从而允许事务在并发执行的情况下保持一致性和隔离性。</li>
<li><strong>设计数据库表需要注意哪些？数据库慢查询优化怎么做？</strong></li>
</ol>
<ul>
<li>设计数据库表时需要考虑数据模型的规范性、冗余度、数据完整性和性能等方面。</li>
<li>数据库慢查询优化可以通过使用索引、优化查询语句、适当分表等方式来提高查询性能。可以通过查看慢查询日志和分析执行计划来找出慢查询的原因，并进行相应的优化。</li>
</ul>
<ol>
<li><strong>truncate 和 drop有哪些区别？</strong></li>
</ol>
<ul>
<li><code>truncate</code> 是用于删除表中的所有行，并释放表空间，但保留表结构的操作。<code>drop</code> 是用于删除整个表的操作，包括表结构和数据。</li>
<li><code>truncate</code> 是 DDL（数据定义语言）操作，会自动提交事务，并且不触发事务日志，速度较快。<code>drop</code> 是 DDL 操作，会立即释放表空间，但需要较长的时间来执行。</li>
</ul>
<ol>
<li><strong>乐观锁和悲观锁分别应用在哪些场景？</strong></li>
</ol>
<ul>
<li>乐观锁适用于读多写少的场景，它认为并发冲突的概率较低，每次操作都进行乐观估计，不进行加锁，只在提交时检查数据是否被修改。</li>
<li>悲观锁适用于写多读少或写写冲突较多的场景，它认为并发冲突的概率较高，每次操作都进行悲观估计，通过加锁来保证数据的一致性。</li>
</ul>
<ol>
<li><strong>计算机的体系结构是怎样的？说一下一些基本的硬件设备</strong> 计算机体系结构包括五个主要部分：中央处理器（CPU）、主存储器（RAM）、输入设备、输出设备和外部存储器。</li>
</ol>
<ul>
<li>CPU 是计算机的核心部件，负责执行指令和处理数据。</li>
<li>RAM 是主存储器，用于存储 CPU 访问的数据和程序。</li>
<li>输入设备包括键盘、鼠标、触摸屏等，用于向计算机输入数据和命令。</li>
<li>输出设备包括显示器、打印机、音响等，用于从计算机获取处理结果。</li>
<li>外部存储器包括硬盘、固态硬盘、光盘等，用于长期存储数据和程序。</li>
</ul>
<p>.shell脚本、python熟悉吗（写两个shell脚本</p>
<pre class="language-none"><code class="language-none">#!/bin/bash

# 源文件目录和备份目录
source_dir="/path/to/source"
backup_dir="/path/to/backup"

# 创建备份目录
mkdir -p $backup_dir

# 备份文件
cp -r $source_dir/* $backup_dir/

# 发送邮件通知
mail -s "Backup Completed" your_email@example.com &lt;&lt;EOF
Backup of $source_dir completed successfully.
EOF
</code></pre>

]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面面</tag>
      </tags>
  </entry>
</search>
