<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Exec</title>
    <url>/2022/09/11/Exec/</url>
    <content><![CDATA[<h2 id="Exec"><a href="#Exec" class="headerlink" title="Exec"></a>Exec</h2><p>在进入靶场后发现窗口ping，猜测可能是SQL注入漏洞，也有可能是命令执行漏洞。</p>
<p>先ping一下本机地址127.0.0.1</p>
<p>有回显，所以是命令执行漏洞。</p>
<p><img src="/../images/Exec/image-20230911105131441.png" alt="image-20230911105131441"></p>
<hr>
<p>在 Web 应用中有时候程序员为了考虑灵活性、简洁性，会在代码调用代码或命令执行函数去处理。比如当应用在调用一些能将字符串转化成代码的函数时，没有考虑用户是否能控制这个字符串，将造成代码执行漏洞。同样调用系统命令处理，将造成命令执行漏洞。</p>
<p>命令执行漏洞的原理是由于应用程序未正确对用户输入进行验证和过滤，导致用户输入被直接或间接地作为命令或代码的一部分执行。攻击者利用这个漏洞，通过注入恶意代码或命令，让应用程序误以为这是合法的输入，从而在目标系统上执行恶意操作。</p>
<h3 id="命令拼接符"><a href="#命令拼接符" class="headerlink" title="命令拼接符:"></a>命令拼接符:</h3><p>命令执行就用命令拼接符执行漏洞命令就行。常见的命令拼接符为以下四种。<br>&amp;:无论左边是false还是true，右边都执行。<br>&amp;&amp;:具有短路效果，左边是false，右边不执行。<br>|:无论左边是false还是true，右边都执行。</p>
<p>||:具有短路效果，左边是true，右边不执行</p>
<hr>
<p>试着查看目录127.0.0.1 &amp;&amp; ls 没反应，试试127.0.0.1 &amp; ls 有回显</p>
<p>发现index.php文件，进入。</p>
<p>查看所有根目录Windows系统为dir，linux为 ls/，猜测为Linux系统先试试127.0.0.1 &amp; ls /(或者127.0.0.1 | ls)</p>
<p>得到目录发现有一个flag文件，flag应该在里面，进行查看。127.0.0.1 &amp; cat /flag（或者127.0.0.1 | cat /flag）</p>
<p>拿到flag!</p>
<p><img src="/../images/Exec/image-20230911105144151.png" alt="image-20230911105144151"></p>
]]></content>
      <categories>
        <category>buuctf</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>命令执行漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>N1book</title>
    <url>/2023/09/15/N1book/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="常见信息收集"><a href="#常见信息收集" class="headerlink" title="常见信息收集"></a>常见信息收集</h2><p><img src="/../images/N1book/image-20230915145523146.png" alt="image-20230915145523146"></p>
<p>进入靶场查看源码没有收获，使用工具对网站目录进行扫描。</p>
<p>dirb没扫到，改用dirsearch。</p>
<p><img src="/../images/N1book/image-20230917122519644.png" alt="image-20230917122519644"></p>
<p>发现存在<code>robots.txt</code>,<code>index.php~</code>,<code>.index.php.swp</code>等文件，分别存放了flag的3个部分</p>
<pre class="language-none"><code class="language-none">- `robots.txt`:告诉爬虫哪些页面可以爬取
- `index.php~`:php的备份有两种：`*.php~`和`*.php.bak`
- `.index.php.swp`:当vim出现异常会产生`.swp`文件，可以通过`vim -r .index.php.swp`恢复文件</code></pre>

<p>访问robots.txt</p>
<p><img src="/../images/N1book/image-20230915160035966.png" alt="image-20230915160035966"></p>
<p>得到flag存放信息继续访问提示文件</p>
<p><img src="/../images/N1book/image-20230915160114816.png" alt="image-20230915160114816"></p>
<p>拿到部分flag。</p>
<p><img src="/../images/N1book/image-20230915160206249.png" alt="image-20230915160206249"></p>
<p>访问index.php~拿到第二部分flag。</p>
<p>访问.index.php.swp</p>
<p><img src="/../images/N1book/image-20230915160451066.png" alt="image-20230915160451066"></p>
<p>下载文件查看。</p>
<p><img src="/../images/N1book/image-20230915160806614.png" alt="image-20230915160806614"></p>
<p>拿到第三部分flag。拼接在一起。</p>
<p><img src="/../images/N1book/image-20230915160921280.png" alt="image-20230915160921280"></p>
<h2 id="粗心的小李"><a href="#粗心的小李" class="headerlink" title="粗心的小李"></a>粗心的小李</h2><p><img src="/../images/N1book/image-20230918162128927.png" alt="image-20230918162128927"></p>
<p>进入靶场，可以看到是和git泄露漏洞相关。</p>
<h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。当前大量开发人员使用git进行版本控制，对站点自动部署。攻击者可以利用该漏洞下载git文件夹里的所有内容。如果文件夹内有敏感信息比如站点源码、数据库账户密码等，攻击者可能直接控制服务器。如果配置不当，可能会将.git文件夹直接部署到线上环境。这就引起了git泄露漏洞。</p>
<h3 id="git目录"><a href="#git目录" class="headerlink" title=".git目录"></a>.git目录</h3><pre class="language-none"><code class="language-none">config - 包含一些配置选项
description - 仓库的描述信息，主要给gitweb等git托管系统使用
HEAD - 指定当前分支,映射到ref引用，能够找到下一次commit的前一次哈希值
hooks - 存放可在某些指令前后触发运行的钩子脚本（hook scripts），默认包含一些脚本样例
index - 这个文件就是我们前面提到的暂存区（stage），是一个二进制文件
info - 存放仓库的信息
objects - 存储所有Git的数据对象,对象的SHA1哈希值的前两位是文件夹名称，后38位作为对象文件名
refs - 存储各个分支指向的目标提交
</code></pre>

<p><a href="https://zhuanlan.zhihu.com/p/455435143%EF%BC%88Git%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93%EF%BC%89">https://zhuanlan.zhihu.com/p/455435143（Git信息泄露原理解析及利用总结）</a></p>
<p>使用dirsearch工具扫描，需要设置扫描间隔时间和线程数，默认情况无法扫描。本次使用的单线程模式且间隔时间为0.1.</p>
<p><a href="https://blog.csdn.net/m0_37268841/article/details/125565452">https://blog.csdn.net/m0_37268841/article/details/125565452</a></p>
<p>（dirsearch工具常见参数）</p>
<p><img src="/../images/N1book/image-20230918163952795.png" alt="image-20230918163952795"></p>
<p>证明存在git泄露漏洞</p>
<p>使用githack工具泄露的文件（python2运行）或者scrabble。</p>
<p>会得到一个index.html文件打开拿到flag。</p>
<h2 id="SQL注入1"><a href="#SQL注入1" class="headerlink" title="SQL注入1"></a>SQL注入1</h2><p><img src="/../images/N1book/image-20230918165610498.png" alt="image-20230918165610498"></p>
<p>进入靶场，看似有输入表单点击无反应。直接在url注入，尝试1.2</p>
<p><img src="/../images/N1book/image-20230918165828443.png" alt="image-20230918165828443"></p>
<p><img src="/../images/N1book/image-20230918165837170.png" alt="image-20230918165837170"></p>
<p><img src="/../images/N1book/image-20230918165909456.png" alt="image-20230918165909456"></p>
<p>插入‘变化所以是字符注入，</p>
<p>测试注入列数</p>
<p>Index.php?id=1’ order by 3 –+</p>
<p><img src="/../images/N1book/image-20230918170021585.png" alt="image-20230918170021585"></p>
<p>测试注入点</p>
<p><img src="/../images/N1book/image-20230918170246786.png" alt="image-20230918170246786"></p>
<p>测试数据库</p>
<p><img src="/../images/N1book/image-20230918170322140.png" alt="image-20230918170322140"></p>
<p>测表名</p>
<p><img src="/../images/N1book/image-20230918170544720.png" alt="image-20230918170544720"></p>
<p>查列名</p>
<p><img src="/../images/N1book/image-20230918170711429.png" alt="image-20230918170711429"></p>
<p>查看表里数据</p>
<p><img src="/../images/N1book/image-20230918170928545.png" alt="image-20230918170928545"></p>
<p>使用sqlmap试试。</p>
<p><img src="/../images/N1book/image-20230918171103395.png" alt="image-20230918171103395"></p>
<!-- more -->

]]></content>
      <categories>
        <category>buuctf</category>
      </categories>
      <tags>
        <tag>buuctf</tag>
        <tag>N1book</tag>
        <tag>web入门</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper</title>
    <url>/2024/02/27/ZooKeeper/</url>
    <content><![CDATA[<h2 id="ZooKeeper概念"><a href="#ZooKeeper概念" class="headerlink" title="ZooKeeper概念"></a>ZooKeeper概念</h2><ul>
<li>zookeeper是apache Hadoop项目下的一个子项目，是一个树形目录服务。</li>
<li>Zookeeper翻译过来就是动物园管理员，用来管理Hadoop（大象）、Hive（蜜蜂）、Pig</li>
<li>分布式的，开源的分布式应用程序的协调服务</li>
<li>主要功能包括：<ul>
<li>配置管理</li>
<li>分布式锁</li>
<li>集群管理</li>
</ul>
</li>
</ul>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>Zookeeper:一个领导者（Leader)，多个跟随者（Follower）组成的集群。</li>
<li>集群中只要有半数以上节点存活，Zookeeper集群就能正常服务。所以Zookeeper适合安装奇数台服务器。</li>
<li>全局数据一致:每个Server保存一份相同的数据副本，Client无论连接到哪个Server，数据都是一致的。</li>
<li>更新请求顺序执行，来白同一个Client的更新请求按其发送顺序依次执行。</li>
<li>数据更新原子性，一次数据更新要么成功，要么失败。</li>
<li>实时性,在一定时间范围内，Client能读到最新数据。</li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><img src="/../images/ZooKeeper/image-20240301162933691.png" alt="image-20240301162933691"></p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>ZooKeeper</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2222/09/01/hello-world/</url>
    <content><![CDATA[<span id="more"></span>

<p>记录美好</p>
<!-- more -->

]]></content>
  </entry>
  <entry>
    <title>sql注入</title>
    <url>/2024/03/03/sql%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h2 id="sql注入原理"><a href="#sql注入原理" class="headerlink" title="sql注入原理"></a>sql注入原理</h2><p>sql注入本质就是把用户输入的参数当作SQL语句执行，web应用程序对用户输入数据的合法性没有判断和过滤，攻击者可以通过构造不同的SQL语句来实现对数据库的操作。其可能造成信息泄露，上传webshell，篡改网页信息等。</p>
<p>sqlmap常用注入语句</p>
<ol>
<li>扫描目标URL：sqlmap -u &lt;目标URL&gt;</li>
<li>扫描目标URL并检测注入：sqlmap -u &lt;目标URL&gt; –dbs</li>
<li>指定注入参数进行测试：sqlmap -u &lt;目标URL&gt; -p &lt;注入参数&gt;</li>
<li>指定数据库类型进行测试：sqlmap -u &lt;目标URL&gt; –dbms &lt;数据库类型&gt;</li>
<li>使用Cookie进行测试：sqlmap -u &lt;目标URL&gt; –cookie “&lt;Cookie数据&gt;”</li>
<li>执行具体的SQL注入攻击：sqlmap -u &lt;目标URL&gt; –data “&lt;POST数据&gt;” –method POST –level 5 –risk 3</li>
</ol>
<h2 id="SQL注入分类"><a href="#SQL注入分类" class="headerlink" title="SQL注入分类"></a>SQL注入分类</h2><h3 id="联合注入"><a href="#联合注入" class="headerlink" title="联合注入"></a>联合注入</h3><p>sql注入一般流程：</p>
<ol>
<li>判断注入点是否存在以及类型</li>
<li>order by猜字段数</li>
<li>联合查询寻找输出点</li>
<li>查库名 union select 1,2,3,database()</li>
<li>查表名 </li>
<li>查字段</li>
</ol>
<h3 id="头部注入"><a href="#头部注入" class="headerlink" title="头部注入"></a>头部注入</h3><p>HTTP头部注入是指注入字段在HTTP请求头的字段中，一般是user-agent，referer。</p>
<p>user-agent：提供浏览器类型，操作系统版本，插件信息等</p>
<p>referer：指明当前请求来自那里</p>
<h4 id="user-agent案例-以sqllibs18为例"><a href="#user-agent案例-以sqllibs18为例" class="headerlink" title="user-agent案例-以sqllibs18为例"></a>user-agent案例-以sqllibs18为例</h4><p><img src="/../images/sql%E6%B3%A8%E5%85%A5/image-20240303144412570.png" alt="image-20240303144412570"></p>
<p>输入用户名和密码发现屏幕回显user-agent</p>
<p><img src="/../images/sql%E6%B3%A8%E5%85%A5/image-20240303145726412.png" alt="image-20240303145726412"></p>
<p>猜测注入点可能在此bp抓包看看</p>
<p><img src="/../images/sql%E6%B3%A8%E5%85%A5/image-20240303145942758.png" alt="image-20240303145942758"></p>
<p>修改user-agent后面内容试试，改为 ’</p>
<p><img src="/../images/sql%E6%B3%A8%E5%85%A5/image-20240303150234394.png" alt="image-20240303150234394"></p>
<p>发现报错，闭合方式应该为‘#</p>
<p><img src="/../images/sql%E6%B3%A8%E5%85%A5/image-20240303151704182.png" alt="image-20240303151704182"></p>
<p>接下来入正常进行即可。</p>
<h3 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h3><p>在攻击过程中服务器开启错误回显，页面会返回错误信息，利用报错函数来获取信息</p>
<ol>
<li>updatexml()</li>
</ol>
<p>updatexml(XML_document,XPayh_string,new_value);</p>
<p>简单来说就是updatexml(目标xml内容，xml文档路径，更新的内容)</p>
<p>我们在xml文档路径写入了子查询，和特俗字符拼接在其，因为不符合输入路径规则报错，先执行了子查询可以得到我们需要的消息。0x7e是~的16进制表示。</p>
<p>语句L:select * from aaa where id=1 and updatexml(1,concat（0x7e,(select user()),1)</p>
<ol start="2">
<li>floor()</li>
</ol>
<p>floor和count和group by三个函数在一起会报错。</p>
<p>语句：select * from aaa where id=1 and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a);</p>
<ol start="3">
<li>extractvalue()</li>
</ol>
<p>原理同updatexml().</p>
<p>语句：select * from aaa where id =1 and(extractvalue(1,concat(0x7e,(select user(),0x7e)));</p>
<h3 id="布尔型盲注"><a href="#布尔型盲注" class="headerlink" title="布尔型盲注"></a>布尔型盲注</h3><p>主要用于网站无输出点，并且关闭了错误回显。</p>
<p>常用函数：</p>
<ul>
<li>length（）：函数返回值为字符串长度。</li>
<li>substr():截取字符串，substr(string,start,length)</li>
<li>ascii():返回字符串中第一关字符的ascii值</li>
</ul>
<h3 id="延时注入"><a href="#延时注入" class="headerlink" title="延时注入"></a>延时注入</h3><p>有时候会遇到无论如何操作页面返回都是正常的情况，这时候考虑使用延时注入</p>
<p>使用函数：sleep（）。</p>
<h3 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h3><p>在一些老版本的php中可以开启防御函数magic_quotes_gpc，也叫魔术引号，作用是判断用户提交的数据，包括有get、post、cookie过来的数据里面的特殊字符增加转义字符”\”，以确保这些数据不会因为特殊字符引起的污染而出现致命的错误。单引号(‘)、双引号(“)、反斜线（\）等字符都会被加上反斜线。</p>
<p>因为单引号和双引号里面的内容都是字符串，如果我们输入的东西不能闭合掉单引号双引号，就无法产生sql注入，在新版本中虽然取消了魔术引号，但是很多cms依然会用一些函数替代，比如addslashes()等。</p>
<p>那么我们怎么逃逸出这个转义呢？这时候可以使用宽字节注入。</p>
<p>原理：如果程序设计数据库编码的时候设置了非英文编码，php发送请求到mysql时经过一次gbk编码，因为gbk是双字节编码，当设置gbk编码后，遇到了连续两个字节都符合gbk取值范围，会自动解析成一个汉字，输入%df%27，本来\会转义%27（’）,但\（%5c）的编码数为92，%df的编码数为223，符合取值范围，于是%df%5c会解析成为一个汉字“運”，单引号就逃逸了出来，从而绕过转义造成注入。</p>
<ul>
<li>注：1.POST注入并不会进行URL转码，所以需要改hex。</li>
<li>2.在查询时用到的表名字段名不能用原来的‘admin’形式，这时候可以转换十六进制，或者用子查询。</li>
<li>3.还可以用汉字绕过。</li>
</ul>
<h3 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h3><p>在SQL中，分号表示一条SQL语句的介绍，在结束语句后再构造一条语句，就会造成堆叠注入。</p>
<h3 id="DNSlog注入"><a href="#DNSlog注入" class="headerlink" title="DNSlog注入"></a>DNSlog注入</h3><p>利用场景：在某些无法直接利用漏洞获得回显时如果用盲注来做效率低下且容易被waf拦截，但是目标可以发起请求，这个时候我们可以通过DNS解析把我们想要获得的数据外带出来。</p>
<p>注入过程：通过子查询将内容拼接到域名内，让load_file()去访问共享文件，访问的域名被记录，读取远程共享文件，通过拼接出函数做查询，拼接到域名中，访问时将访问服务器，记录后查询该日志。</p>
<p>这里需要用到一个mysql函数LOAD_FILE()：读取一个文件并将其内容作为字符串返回。</p>
]]></content>
      <categories>
        <category>web漏洞</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title>train-www-robots</title>
    <url>/2022/09/11/train-www-robots/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="training-www-Robots"><a href="#training-www-Robots" class="headerlink" title="training-www-Robots"></a>training-www-Robots</h2><h3 id="考察的知识点"><a href="#考察的知识点" class="headerlink" title="考察的知识点"></a>考察的知识点</h3><p>robots.txt 文件是一个文本文件，使用任何一个常见的文 本编辑器，比如 Windows 系统自带的 Notepad，就可以创 建和编辑它[1] 。robots.txt 是一个协议，而不是一个命令。 robots.txt 是搜索引擎中访问网站的时候要查看的第一个 文件。robots.txt 文件告诉蜘蛛程序在服务器上什么文件 是可以被查看的。 当一个搜索蜘蛛访问一个站点时，它会首先检查该站点根 目录下是否存在 robots.txt，如果存在，搜索机器人就会 按照该文件中的内容来确定访问的范围；如果该文件不存 在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保 护的页面。百度官方建议，仅当您的网站包含不希望被搜 索引擎收录的内容时，才需要使用 robots.txt 文件。如果 您希望搜索引擎收录网站上所有内容，请勿建立 robots.txt 文件。 如果将网站视为酒店里的一个房间，robots.txt 就是主人 在房间门口悬挂的“请勿打扰”或“欢迎打扫”的提示牌。这 个文件告诉来访的搜索引擎哪些房间可以进入和参观，哪 些房间因为存放贵重物品，或可能涉及住户及访客的隐私 而不对搜索引擎开放。但 robots.txt 不是命令，也不是防 火墙，如同守门人无法阻止窃贼等恶意闯入者。</p>
<p><a href="https://zhuanlan.zhihu.com/p/29675312#:~:text=%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFRobots%E5%8D%8F%E8%AE%AE%EF%BC%9F,Robots%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B9%9F%E7%A7%B0%E4%B8%BA%E7%88%AC%E8%99%AB%E5%8D%8F%E8%AE%AE%E3%80%81%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8D%8F%E8%AE%AE%E7%AD%89%EF%BC%89%E7%9A%84%E5%85%A8%E7%A7%B0%E6%98%AF%E2%80%9C%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E6%8E%92%E9%99%A4%E6%A0%87%E5%87%86%E2%80%9D%EF%BC%8Crobots.txt%E6%98%AF%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E8%AE%BF%E9%97%AE%E7%BD%91%E7%AB%99%E6%97%B6%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%9F%A5%E7%9C%8B%E7%9A%84%E6%96%87%E4%BB%B6%EF%BC%8C%E5%BD%93%E6%88%91%E4%BB%AC%E7%BD%91%E7%AB%99%E6%9C%89%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%E4%B8%8D%E5%B8%8C%E6%9C%9B%E6%94%B6%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%8A%93%E5%8F%96%E6%97%B6%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87Robots%E5%8D%8F%E8%AE%AE%E6%9D%A5%E5%91%8A%E8%AF%89%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%93%AA%E4%BA%9B%E9%A1%B5%E9%9D%A2%E6%98%AF%E4%B8%8D%E8%83%BD%E6%8A%93%E5%8F%96%E7%9A%84%EF%BC%8C%E5%A4%A7%E5%A4%9A%E7%94%A8%E6%9D%A5%E4%BF%9D%E6%8A%A4%E7%BD%91%E7%AB%99%E7%9A%84%E9%9A%90%E7%A7%81%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E6%AD%BB%E9%93%BE%E3%80%81%E9%87%8D%E5%A4%8D%E9%A1%B5%E9%9D%A2%E7%AD%89%E7%AD%89%E3%80%82">什么是robots协议？robots.txt文件怎么写？ - 知乎 (zhihu.com)</a></p>
<p><img src="/../images/traning-www-robots/image-20230910204135962.png" alt="image-20230910204135962"></p>
<p>打开网页得到这个阅读一下，发现使用robots</p>
<p>在网页链接加上robots.txt</p>
<p><img src="/../images/traning-www-robots/image-20230910204201240.png" alt="image-20230910204201240"></p>
<p>看到flag信息查看flag</p>
<p><img src="/../images/traning-www-robots/image-20230910204211916.png" alt="image-20230910204211916"></p>
<p>拿到flag。</p>
]]></content>
      <categories>
        <category>攻防世界</category>
      </categories>
      <tags>
        <tag>-web -robots</tag>
      </tags>
  </entry>
  <entry>
    <title>upload-labs1</title>
    <url>/2023/09/14/upload-labs1/</url>
    <content><![CDATA[<h2 id="upload-labs-1"><a href="#upload-labs-1" class="headerlink" title="upload-labs-1"></a>upload-labs-1</h2><p><img src="/../images/upload-labs1/image-20230914142612836.png" alt="image-20230914142612836"></p>
<h3 id="关卡简介："><a href="#关卡简介：" class="headerlink" title="关卡简介："></a>关卡简介：</h3><p>上传点使用前端来验证后缀名，使用bp绕过上传木马脚本获取webshell。</p>
<h3 id="查看源码"><a href="#查看源码" class="headerlink" title="查看源码"></a>查看源码</h3><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">checkFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> file <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByName</span><span class="token punctuation">(</span><span class="token string">' upload_file'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>file <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> file <span class="token operator">==</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"请选择要上传的文件!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//定义允许上传的文件类型</span>
    <span class="token keyword">var</span> allow_ext <span class="token operator">=</span> <span class="token string">".jpg|.png|.gif"</span><span class="token punctuation">;</span>
    <span class="token comment">//提取上传文件的类型</span>
    <span class="token keyword">var</span> ext_name <span class="token operator">=</span> file<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//判断上传文件类型是否允许上传</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>allow_ext<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>ext_name <span class="token operator">+</span> <span class="token string">"|"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> errMsg <span class="token operator">=</span> <span class="token string">"该文件不允许上传，请上传"</span> <span class="token operator">+</span> allow_ext <span class="token operator">+</span> <span class="token string">"类型的文件,当前文件类型为："</span> <span class="token operator">+</span> ext_name<span class="token punctuation">;</span>
        <span class="token function">alert</span><span class="token punctuation">(</span>errMsg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>

<p>只允许上传.jpg|.png|.gif类型文件</p>
<p><img src="/../../../zy/Documents/image-20230914150230885.png" alt="image-20230914150230885"></p>
<p>1.查看前端代码删除check函数，或者禁用js</p>
<p><img src="/../images/upload-labs1/image-20230914150556990.png" alt="image-20230914150556990"></p>
<p>2.bp抓包修改后缀</p>
]]></content>
      <tags>
        <tag>uoload-labs</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传</title>
    <url>/2023/09/14/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><p><img src="/../images/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/1627433334141-cb693e43-53e8-4e28-80b9-b2c08e23f2f6.png" alt="web漏洞文件上传.png"></p>
<h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>在某处用户可以上传文件到服务器端，比如个人资料，头像，且后端不对用户上传的文件做处理，攻击者可以利用这个功能上传恶意文件，比如木马，病毒，恶意脚本，后门等。</p>
<h2 id="利用："><a href="#利用：" class="headerlink" title="利用："></a>利用：</h2><p>各种绕过，上传一句话木马。</p>
<p><img src="/../images/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/1627433817849-28573285-fa9c-4d1d-9864-2f822f372ee5.png" alt="文件上传利用思路.png"></p>
<h2 id="文件上传漏洞如何查找及判断"><a href="#文件上传漏洞如何查找及判断" class="headerlink" title="文件上传漏洞如何查找及判断?"></a>文件上传漏洞如何查找及判断?</h2><p>1.黑盒查找：通过工具扫描网站敏感文件、路径，以期获得文件上传地址。或者通过类似于会员中心的上传图片功能进行漏洞测试。网站后台也有上传功能（后台权限不等同于网站权限）。</p>
<p>2.白盒测试：审计代码，寻找上传漏洞。通过抓包、上传等操作判断漏洞是否有效。</p>
<h3 id="文件上传常见验证"><a href="#文件上传常见验证" class="headerlink" title="文件上传常见验证:"></a>文件上传常见验证:</h3><p>后缀名，类型，文件头等<br>后缀名:黑名单,白名单<br>文件类型:MIME<br>信息文件头:内容头信息</p>
<p>简要上传表单代码分析解释</p>
<h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><pre class="language-none"><code class="language-none">trim() 函数移除字符串两侧的空白字符或其他预定义字符。

str_ireplace() 函数替换字符串中的一些字符（不区分大小写）。

substr() 函数返回字符串的一部分。

strrpos() 函数查找字符串在另一字符串中最后一次出现的位置。</code></pre>



<h2 id="防御："><a href="#防御：" class="headerlink" title="防御："></a>防御：</h2><p>1.前端js脚本检测后缀名。（可以有burp抓包修改文件后缀名绕过）</p>
<p>2.后端黑白名单检测（黑名单检测可以通过测试检测规则绕过，白名单检测可以用00截断绕过）</p>
<p>3.content-type检测过滤（bp抓包修改content-type绕过）</p>
<p>4.getimagesize(_)函数检测图片大小是否正常（将木马写入图片绕过）</p>
<p>5.图片二次渲染</p>
<p>6.文件重命名</p>
<h2 id="常见绕过方式"><a href="#常见绕过方式" class="headerlink" title="常见绕过方式"></a>常见绕过方式</h2><p>数据溢出-防匹配(xxx.. .)</p>
<p>符号变异-防匹配（’” ;)</p>
<p>数据截断-防匹配(%00 ;换行)</p>
<p>重复数据-防匹配(参数多次)</p>
<h2 id="上传的参数名解析"><a href="#上传的参数名解析" class="headerlink" title="上传的参数名解析"></a>上传的参数名解析</h2><p>可以修改的东西有？</p>
<pre class="language-none"><code class="language-none">Content-Disposition:	一般可更改

name:	表单参数值，不能更改

filename :文件名，可以更改

Content-Type:文件MIME，视情况更改
</code></pre>

]]></content>
      <tags>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>owasp top10</title>
    <url>/2024/03/05/owasp-top10/</url>
    <content><![CDATA[<h2 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h2><p>注入通常是指将不受信任的数据作为命令或查询的一部分发送到解析器时，会产生注入SQL注入、OS注入和LDAP注入的缺陷。攻击者的恶意数据可以诱使解析器在没有适当授权的情况下执行非预期命令访问数据。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>一般常见的SQL注入和OS注入</p>
<ul>
<li><p>SQL注入：</p>
</li>
<li><p>SQL注入防御：</p>
<ol>
<li>对输入进行严格过滤和转义</li>
<li>关闭错误回显</li>
<li>限制SQL服务的远程访问，只开放给特定开发人员</li>
<li>代码审计–最有效的检测应用程序的注入风险的方法之一</li>
<li>使用成熟的waf</li>
</ol>
</li>
<li><p>os注入：web开发使用的编程语言中，大多数能通过shell执行os命令。通过shell执行OS命令时或者开发中用到某个方法其内部利用了shell时，就有可能出现OS命令被任意执行的情况。</p>
</li>
<li><p>OS注入的防御：</p>
<ol>
<li>使用安全的函数对传递给OS命令参数进行转义</li>
<li>不将外界传入的字符串传递给命令行参数</li>
<li>选择不调用OS命令的方法实现</li>
</ol>
<p>（不利用 shell的功能，既能杜绝os命令注入漏洞，又消除了调用os命令的系统开销，提高应用性能）</p>
</li>
</ul>
<h2 id="敏感数据泄露"><a href="#敏感数据泄露" class="headerlink" title="敏感数据泄露"></a>敏感数据泄露</h2><p>原理：应用维护或者开发人员无意间上传敏感数据，如GitHub文件泄露敏感数据文件的权限设置错误。</p>
<p>常见攻击方式主要是扫描应用程序获得敏感数据</p>
<p>防御：</p>
<ol>
<li>对系统处理、存储或传输的数据分类进行访问控制。</li>
<li>确保存储的敏感数据被加密</li>
<li>确保使用了强大的标准算法或密码、参数。协议和秘钥，</li>
<li>禁止缓存对包含敏感数据的响应</li>
</ol>
<h2 id="失效的身份认证"><a href="#失效的身份认证" class="headerlink" title="失效的身份认证"></a>失效的身份认证</h2><p>原理：应用中负责认证会话管理的部分没有正确实现，使得攻击者得以泄露密码，口令或令牌，进而可能获取其他用户的身份。</p>
<p>影响：</p>
<ul>
<li>盗用账号与身份（撞库，弱密码尝试之类）</li>
</ul>
<p>防御：</p>
<ul>
<li>使用强密码</li>
<li>限制或延迟失败的登录尝试，并记录所有失败尝试</li>
<li>网站应该具备良好的权限控制与管理</li>
<li>使用SSL对数据流进行加密</li>
</ul>
<h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>往网站上注入恶意脚本，当用户浏览网页时候恶意代码执行，从而获取用户敏感信息。分为存储型，DOM型，反射型</p>
<h4 id="反射型XSS："><a href="#反射型XSS：" class="headerlink" title="反射型XSS："></a>反射型XSS：</h4><p>非持久化攻击，需要欺骗用户点击链接才能触发XSS代码。应用程序或API包括未验证和未转义的用户输入作为html输出的一部分。</p>
<h4 id="存储型XSS："><a href="#存储型XSS：" class="headerlink" title="存储型XSS："></a>存储型XSS：</h4><p> 持久化攻击，代码存在服务器中，如个人信息里。访问该页面时候触发代码执行，容易造成蠕虫，盗窃cookie。</p>
<h4 id="DOM型："><a href="#DOM型：" class="headerlink" title="DOM型："></a>DOM型：</h4><p>不经过后端，domxss是基于文档对象模型（document object model，dom)的漏洞</p>
<p>，攻击者向服务器发送一个带有恶意js代码的请求，服务器的响应不i会以任何形式包含攻击者的脚本。当用户的浏览器处理这个响应时，DOM对象就会处理XSS代码，导致XSS漏洞。</p>
<h4 id="防御："><a href="#防御：" class="headerlink" title="防御："></a>防御：</h4><ul>
<li>存储型：后台编写过滤器，对一些HTML标签和特殊的字符进行转义</li>
<li>反射型：对特殊字符转义</li>
<li>dom:检测是否包含一些特殊的函数可以造成危害的地方</li>
<li>使用字段转义的xss框架，如react js</li>
<li>启用CSP（content security policy），这是一种对抗XSS纵深防御弥补控制。</li>
</ul>
<h2 id="外部实体（XXE）"><a href="#外部实体（XXE）" class="headerlink" title="外部实体（XXE）"></a>外部实体（XXE）</h2><p>XXE（XML external entity injection）外部实体注入漏洞，XML在引用外部实体时候，攻击者可以构造恶意的XML代码，以造成任意文件读取、命令执行甚至是中断服务器。</p>
<p>主要成因是因为XML协议文档本身的设计特性，可以引入外部的资源，定义XML文件时使用的外部实体引入功能。 </p>
<p>影响：读取服务器敏感资料比如/etc/password</p>
<p>读取源码</p>
<p>防御：关闭DTD，禁止外部实体引入，过滤用户提交的XML数据</p>
<h2 id="安全配置错误"><a href="#安全配置错误" class="headerlink" title="安全配置错误"></a>安全配置错误</h2><p>原理：操作者不当配置（默认配置，临时配置，开源云存储，HTTP标头配置），导致攻击者可以利用这些配置获取到更高权限，安全配置错误可以发生在各个层面，包含平台、web服务器、数据库、架构和代码</p>
<p>防御：</p>
<ul>
<li>使用的服务不包含任何不必要的功能、组件、文档和用例，移除或不安装不适用的功能和框架</li>
<li>即使检测系统服务版本打上漏洞补丁</li>
<li>自动化安装部署</li>
</ul>
<h2 id="失效访问控制"><a href="#失效访问控制" class="headerlink" title="失效访问控制"></a>失效访问控制</h2><p>水平越权：系统只验证能够访问数据的角色没有对数据做细分导致A能访问B的数据。</p>
<p>垂直越权：后台未对权限做限制，导致攻击者可以通过猜测其他管理页面的url或者敏感的参数信息变更权限。</p>
<p>防御：</p>
<ul>
<li>对参数的白名单过滤</li>
<li>对权限的控制管理重新设计与限制</li>
<li>前后端同时校验，双重验证机制</li>
<li>用户注销后使其jwt令牌失效</li>
</ul>
<h2 id="不安全的反序列化"><a href="#不安全的反序列化" class="headerlink" title="不安全的反序列化"></a>不安全的反序列化</h2><p>介绍：</p>
<p>序列化：序列化 (Serialization)是将对象的状态信息转换为可以存储或传输(一般是以二进制的形式保存)的形式的过程。<br>反序列化： 与序列化的过程刚好相反。</p>
<p>原理：如果应用对恶意构造的用户输入数据进行反序列化，会产生非预期对象，从而可能导致远程代码执行。或者应用中存在可以反序列化过程中或者之后被改变行为的类，则攻击者可以通过改变应用逻辑或者失实现远程代码执行攻击，称为对象和数据结构攻击。</p>
<p>防御</p>
<ol>
<li>对序列化对象进行完整性检测，比如数字签名防止数据篡改或恶意对象。</li>
<li>在反序列化过程中强制严格的类型限制</li>
<li>在低权限环境中独立运行反序列化代码</li>
<li>不接受来自不信任源的序列化对象，或使用只允许原始数据类型的序列化媒体</li>
<li>对反序列化过程进行日志记录，监控反序列化过程，在发现疑似反序列化攻击时进行警报。</li>
</ol>
<h2 id="使用含已知漏洞的组件"><a href="#使用含已知漏洞的组件" class="headerlink" title="使用含已知漏洞的组件"></a>使用含已知漏洞的组件</h2><p>限制的服务器都需要使用很多组件，库、框架等软件组件和应用有着相同权限。如果存在有漏洞的组件，那么攻击就能导致数据泄露甚至控制服务器。组件中的漏洞会导致整个应用和API安全性下降。</p>
<p>防御：</p>
<ul>
<li>移除不使用的功能组件</li>
<li>从正规渠道获取组件</li>
<li>及时更新、修复组件漏洞</li>
</ul>
<h2 id="不足的日志记录和监控"><a href="#不足的日志记录和监控" class="headerlink" title="不足的日志记录和监控"></a>不足的日志记录和监控</h2><p>日志和监控不足，再加上缺失或无效的事件响应，允许攻击者进一步攻击系统。</p>
<p>防御：</p>
<ul>
<li>启用日志监控、告警机制</li>
<li>尽可能的完整记录所有日志</li>
</ul>
<h2 id="其他常见web漏洞"><a href="#其他常见web漏洞" class="headerlink" title="其他常见web漏洞"></a>其他常见web漏洞</h2><hr>
<h2 id="CSRF跨站请求伪造"><a href="#CSRF跨站请求伪造" class="headerlink" title="CSRF跨站请求伪造"></a>CSRF跨站请求伪造</h2><p><img src="/../images/owasp-top10/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZW5saWppYW4=,size_16,color_FFFFFF,t_70.png"></p>
<p>简单来说就是用户拥有网站A的cookie,攻击者诱导用户点击网站B从而获得用户cookie假装为用户去访问网站A</p>
<p>防御：</p>
<ul>
<li>在请求参数中增加一个随机token</li>
<li>敏感操作使用POST以表单形式提交，避免token泄露。</li>
</ul>
<h2 id="SSRF服务器端请求伪造"><a href="#SSRF服务器端请求伪造" class="headerlink" title="SSRF服务器端请求伪造"></a>SSRF服务器端请求伪造</h2><p>SSRF是一种由攻击者构造形成由服务器端发起请求的安全的一个安全漏洞。</p>
<p>原理：服务器端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。</p>
<p>ssrf是利用存在缺陷的web应用作为代理攻击远程和本地服务器。</p>
<p>防御：</p>
<ol>
<li>过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一类型的文件，那么在返回结果展示给用户之前先验证返回是信息是否符合标准。</li>
<li>统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</li>
<li>限制请求的端口为哦HTTP常用端口，如80，8080，8090，443</li>
<li>黑名单内网IP。避免应用被用来获取内网数据，攻击内网。</li>
<li>禁止不需要的协议。</li>
</ol>
<p>参考文章：</p>
<p><a href="https://blog.csdn.net/qq_43378996/article/details/124050308">SSRF漏洞原理攻击与防御(超详细总结)-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/angry_program/article/details/107855078">目录穿越/遍历漏洞 – 学习笔记_目录遍历漏洞描述-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_32261191/article/details/101686779">常见的Web漏洞——命令注入_命令注入漏洞-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/weixin_50464560/article/details/120926097">WAF绕过思路整理(挺全)_waf绕过总结-CSDN博客</a></p>
]]></content>
      <categories>
        <category>web漏洞</category>
      </categories>
      <tags>
        <tag>常见web漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>随便看看</title>
    <url>/2024/04/14/%E9%9A%8F%E4%BE%BF%E7%9C%8B%E7%9C%8B/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
