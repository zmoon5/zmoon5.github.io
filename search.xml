<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Exec</title>
    <url>/2022/09/11/Exec/</url>
    <content><![CDATA[<h2 id="Exec"><a href="#Exec" class="headerlink" title="Exec"></a>Exec</h2><p>在进入靶场后发现窗口ping，猜测可能是SQL注入漏洞，也有可能是命令执行漏洞。</p>
<p>先ping一下本机地址127.0.0.1</p>
<p>有回显，所以是命令执行漏洞。</p>
<p><img src="/../images/Exec/image-20230911105131441.png" alt="image-20230911105131441"></p>
<hr>
<p>在 Web 应用中有时候程序员为了考虑灵活性、简洁性，会在代码调用代码或命令执行函数去处理。比如当应用在调用一些能将字符串转化成代码的函数时，没有考虑用户是否能控制这个字符串，将造成代码执行漏洞。同样调用系统命令处理，将造成命令执行漏洞。</p>
<p>命令执行漏洞的原理是由于应用程序未正确对用户输入进行验证和过滤，导致用户输入被直接或间接地作为命令或代码的一部分执行。攻击者利用这个漏洞，通过注入恶意代码或命令，让应用程序误以为这是合法的输入，从而在目标系统上执行恶意操作。</p>
<h3 id="命令拼接符"><a href="#命令拼接符" class="headerlink" title="命令拼接符:"></a>命令拼接符:</h3><p>命令执行就用命令拼接符执行漏洞命令就行。常见的命令拼接符为以下四种。<br>&amp;:无论左边是false还是true，右边都执行。<br>&amp;&amp;:具有短路效果，左边是false，右边不执行。<br>|:无论左边是false还是true，右边都执行。</p>
<p>||:具有短路效果，左边是true，右边不执行</p>
<hr>
<p>试着查看目录127.0.0.1 &amp;&amp; ls 没反应，试试127.0.0.1 &amp; ls 有回显</p>
<p>发现index.php文件，进入。</p>
<p>查看所有根目录Windows系统为dir，linux为 ls/，猜测为Linux系统先试试127.0.0.1 &amp; ls /(或者127.0.0.1 | ls)</p>
<p>得到目录发现有一个flag文件，flag应该在里面，进行查看。127.0.0.1 &amp; cat /flag（或者127.0.0.1 | cat /flag）</p>
<p>拿到flag!</p>
<p><img src="/../images/Exec/image-20230911105144151.png" alt="image-20230911105144151"></p>
]]></content>
      <categories>
        <category>buuctf</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>命令执行漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>N1book</title>
    <url>/2023/09/15/N1book/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="常见信息收集"><a href="#常见信息收集" class="headerlink" title="常见信息收集"></a>常见信息收集</h2><p><img src="/../images/N1book/image-20230915145523146.png" alt="image-20230915145523146"></p>
<p>进入靶场查看源码没有收获，使用工具对网站目录进行扫描。</p>
<p>dirb没扫到，改用dirsearch。</p>
<p><img src="/../images/N1book/image-20230917122519644.png" alt="image-20230917122519644"></p>
<p>发现存在<code>robots.txt</code>,<code>index.php~</code>,<code>.index.php.swp</code>等文件，分别存放了flag的3个部分</p>
<pre class="language-none"><code class="language-none">- `robots.txt`:告诉爬虫哪些页面可以爬取
- `index.php~`:php的备份有两种：`*.php~`和`*.php.bak`
- `.index.php.swp`:当vim出现异常会产生`.swp`文件，可以通过`vim -r .index.php.swp`恢复文件</code></pre>

<p>访问robots.txt</p>
<p><img src="/../images/N1book/image-20230915160035966.png" alt="image-20230915160035966"></p>
<p>得到flag存放信息继续访问提示文件</p>
<p><img src="/../images/N1book/image-20230915160114816.png" alt="image-20230915160114816"></p>
<p>拿到部分flag。</p>
<p><img src="/../images/N1book/image-20230915160206249.png" alt="image-20230915160206249"></p>
<p>访问index.php~拿到第二部分flag。</p>
<p>访问.index.php.swp</p>
<p><img src="/../images/N1book/image-20230915160451066.png" alt="image-20230915160451066"></p>
<p>下载文件查看。</p>
<p><img src="/../images/N1book/image-20230915160806614.png" alt="image-20230915160806614"></p>
<p>拿到第三部分flag。拼接在一起。</p>
<p><img src="/../images/N1book/image-20230915160921280.png" alt="image-20230915160921280"></p>
<h2 id="粗心的小李"><a href="#粗心的小李" class="headerlink" title="粗心的小李"></a>粗心的小李</h2><p><img src="/../images/N1book/image-20230918162128927.png" alt="image-20230918162128927"></p>
<p>进入靶场，可以看到是和git泄露漏洞相关。</p>
<h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。当前大量开发人员使用git进行版本控制，对站点自动部署。攻击者可以利用该漏洞下载git文件夹里的所有内容。如果文件夹内有敏感信息比如站点源码、数据库账户密码等，攻击者可能直接控制服务器。如果配置不当，可能会将.git文件夹直接部署到线上环境。这就引起了git泄露漏洞。</p>
<h3 id="git目录"><a href="#git目录" class="headerlink" title=".git目录"></a>.git目录</h3><pre class="language-none"><code class="language-none">config - 包含一些配置选项
description - 仓库的描述信息，主要给gitweb等git托管系统使用
HEAD - 指定当前分支,映射到ref引用，能够找到下一次commit的前一次哈希值
hooks - 存放可在某些指令前后触发运行的钩子脚本（hook scripts），默认包含一些脚本样例
index - 这个文件就是我们前面提到的暂存区（stage），是一个二进制文件
info - 存放仓库的信息
objects - 存储所有Git的数据对象,对象的SHA1哈希值的前两位是文件夹名称，后38位作为对象文件名
refs - 存储各个分支指向的目标提交
</code></pre>

<p><a href="https://zhuanlan.zhihu.com/p/455435143%EF%BC%88Git%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93%EF%BC%89">https://zhuanlan.zhihu.com/p/455435143（Git信息泄露原理解析及利用总结）</a></p>
<p>使用dirsearch工具扫描，需要设置扫描间隔时间和线程数，默认情况无法扫描。本次使用的单线程模式且间隔时间为0.1.</p>
<p><a href="https://blog.csdn.net/m0_37268841/article/details/125565452">https://blog.csdn.net/m0_37268841/article/details/125565452</a></p>
<p>（dirsearch工具常见参数）</p>
<p><img src="/../images/N1book/image-20230918163952795.png" alt="image-20230918163952795"></p>
<p>证明存在git泄露漏洞</p>
<p>使用githack工具泄露的文件（python2运行）或者scrabble。</p>
<p>会得到一个index.html文件打开拿到flag。</p>
<h2 id="SQL注入1"><a href="#SQL注入1" class="headerlink" title="SQL注入1"></a>SQL注入1</h2><p><img src="/../images/N1book/image-20230918165610498.png" alt="image-20230918165610498"></p>
<p>进入靶场，看似有输入表单点击无反应。直接在url注入，尝试1.2</p>
<p><img src="/../images/N1book/image-20230918165828443.png" alt="image-20230918165828443"></p>
<p><img src="/../images/N1book/image-20230918165837170.png" alt="image-20230918165837170"></p>
<p><img src="/../images/N1book/image-20230918165909456.png" alt="image-20230918165909456"></p>
<p>插入‘变化所以是字符注入，</p>
<p>测试注入列数</p>
<p>Index.php?id=1’ order by 3 –+</p>
<p><img src="/../images/N1book/image-20230918170021585.png" alt="image-20230918170021585"></p>
<p>测试注入点</p>
<p><img src="/../images/N1book/image-20230918170246786.png" alt="image-20230918170246786"></p>
<p>测试数据库</p>
<p><img src="/../images/N1book/image-20230918170322140.png" alt="image-20230918170322140"></p>
<p>测表名</p>
<p><img src="/../images/N1book/image-20230918170544720.png" alt="image-20230918170544720"></p>
<p>查列名</p>
<p><img src="/../images/N1book/image-20230918170711429.png" alt="image-20230918170711429"></p>
<p>查看表里数据</p>
<p><img src="/../images/N1book/image-20230918170928545.png" alt="image-20230918170928545"></p>
<p>使用sqlmap试试。</p>
<p><img src="/../images/N1book/image-20230918171103395.png" alt="image-20230918171103395"></p>
<!-- more -->

]]></content>
      <categories>
        <category>buuctf</category>
      </categories>
      <tags>
        <tag>buuctf</tag>
        <tag>N1book</tag>
        <tag>web入门</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper</title>
    <url>/2024/02/27/ZooKeeper/</url>
    <content><![CDATA[<h2 id="ZooKeeper概念"><a href="#ZooKeeper概念" class="headerlink" title="ZooKeeper概念"></a>ZooKeeper概念</h2><ul>
<li>zookeeper是apache Hadoop项目下的一个子项目，是一个树形目录服务。</li>
<li>Zookeeper翻译过来就是动物园管理员，用来管理Hadoop（大象）、Hive（蜜蜂）、Pig</li>
<li>分布式的，开源的分布式应用程序的协调服务</li>
<li>主要功能包括：<ul>
<li>配置管理</li>
<li>分布式锁</li>
<li>集群管理</li>
</ul>
</li>
</ul>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>Zookeeper:一个领导者（Leader)，多个跟随者（Follower）组成的集群。</li>
<li>集群中只要有半数以上节点存活，Zookeeper集群就能正常服务。所以Zookeeper适合安装奇数台服务器。</li>
<li>全局数据一致:每个Server保存一份相同的数据副本，Client无论连接到哪个Server，数据都是一致的。</li>
<li>更新请求顺序执行，来白同一个Client的更新请求按其发送顺序依次执行。</li>
<li>数据更新原子性，一次数据更新要么成功，要么失败。</li>
<li>实时性,在一定时间范围内，Client能读到最新数据。</li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><img src="/../images/ZooKeeper/image-20240301162933691.png" alt="image-20240301162933691"></p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>ZooKeeper</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2222/09/01/hello-world/</url>
    <content><![CDATA[<span id="more"></span>

<p>记录美好</p>
<!-- more -->

]]></content>
  </entry>
  <entry>
    <title>sql注入</title>
    <url>/2024/03/03/sql%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h2 id="sql注入原理"><a href="#sql注入原理" class="headerlink" title="sql注入原理"></a>sql注入原理</h2><p>sql注入本质就是把用户输入的参数当作SQL语句执行，web应用程序对用户输入数据的合法性没有判断和过滤，攻击者可以通过构造不同的SQL语句来实现对数据库的操作。其可能造成信息泄露，上传webshell，篡改网页信息等。</p>
<p>sqlmap常用注入语句</p>
<ol>
<li>扫描目标URL：sqlmap -u &lt;目标URL&gt;</li>
<li>扫描目标URL并检测注入：sqlmap -u &lt;目标URL&gt; –dbs</li>
<li>指定注入参数进行测试：sqlmap -u &lt;目标URL&gt; -p &lt;注入参数&gt;</li>
<li>指定数据库类型进行测试：sqlmap -u &lt;目标URL&gt; –dbms &lt;数据库类型&gt;</li>
<li>使用Cookie进行测试：sqlmap -u &lt;目标URL&gt; –cookie “&lt;Cookie数据&gt;”</li>
<li>执行具体的SQL注入攻击：sqlmap -u &lt;目标URL&gt; –data “&lt;POST数据&gt;” –method POST –level 5 –risk 3</li>
</ol>
<h2 id="SQL注入分类"><a href="#SQL注入分类" class="headerlink" title="SQL注入分类"></a>SQL注入分类</h2><h3 id="联合注入"><a href="#联合注入" class="headerlink" title="联合注入"></a>联合注入</h3><p>sql注入一般流程：</p>
<ol>
<li>判断注入点是否存在以及类型</li>
<li>order by猜字段数</li>
<li>联合查询寻找输出点</li>
<li>查库名 union select 1,2,3,database()</li>
<li>查表名 </li>
<li>查字段</li>
</ol>
<h3 id="头部注入"><a href="#头部注入" class="headerlink" title="头部注入"></a>头部注入</h3><p>HTTP头部注入是指注入字段在HTTP请求头的字段中，一般是user-agent，referer。</p>
<p>user-agent：提供浏览器类型，操作系统版本，插件信息等</p>
<p>referer：指明当前请求来自那里</p>
<h4 id="user-agent案例-以sqllibs18为例"><a href="#user-agent案例-以sqllibs18为例" class="headerlink" title="user-agent案例-以sqllibs18为例"></a>user-agent案例-以sqllibs18为例</h4><p><img src="/../images/sql%E6%B3%A8%E5%85%A5/image-20240303144412570.png" alt="image-20240303144412570"></p>
<p>输入用户名和密码发现屏幕回显user-agent</p>
<p><img src="/../images/sql%E6%B3%A8%E5%85%A5/image-20240303145726412.png" alt="image-20240303145726412"></p>
<p>猜测注入点可能在此bp抓包看看</p>
<p><img src="/../images/sql%E6%B3%A8%E5%85%A5/image-20240303145942758.png" alt="image-20240303145942758"></p>
<p>修改user-agent后面内容试试，改为 ’</p>
<p><img src="/../images/sql%E6%B3%A8%E5%85%A5/image-20240303150234394.png" alt="image-20240303150234394"></p>
<p>发现报错，闭合方式应该为‘#</p>
<p><img src="/../images/sql%E6%B3%A8%E5%85%A5/image-20240303151704182.png" alt="image-20240303151704182"></p>
<p>接下来入正常进行即可。</p>
<h3 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h3><p>在攻击过程中服务器开启错误回显，页面会返回错误信息，利用报错函数来获取信息</p>
<ol>
<li>updatexml()</li>
</ol>
<p>updatexml(XML_document,XPayh_string,new_value);</p>
<p>简单来说就是updatexml(目标xml内容，xml文档路径，更新的内容)</p>
<p>我们在xml文档路径写入了子查询，和特俗字符拼接在其，因为不符合输入路径规则报错，先执行了子查询可以得到我们需要的消息。0x7e是~的16进制表示。</p>
<p>语句L:select * from aaa where id=1 and updatexml(1,concat（0x7e,(select user()),1)</p>
<ol start="2">
<li>floor()</li>
</ol>
<p>floor和count和group by三个函数在一起会报错。</p>
<p>语句：select * from aaa where id=1 and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a);</p>
<ol start="3">
<li>extractvalue()</li>
</ol>
<p>原理同updatexml().</p>
<p>语句：select * from aaa where id =1 and(extractvalue(1,concat(0x7e,(select user(),0x7e)));</p>
<h3 id="布尔型盲注"><a href="#布尔型盲注" class="headerlink" title="布尔型盲注"></a>布尔型盲注</h3><p>主要用于网站无输出点，并且关闭了错误回显。</p>
<p>常用函数：</p>
<ul>
<li>length（）：函数返回值为字符串长度。</li>
<li>substr():截取字符串，substr(string,start,length)</li>
<li>ascii():返回字符串中第一关字符的ascii值</li>
</ul>
<h3 id="延时注入"><a href="#延时注入" class="headerlink" title="延时注入"></a>延时注入</h3><p>有时候会遇到无论如何操作页面返回都是正常的情况，这时候考虑使用延时注入</p>
<p>使用函数：sleep（）。</p>
<h3 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h3><p>在一些老版本的php中可以开启防御函数magic_quotes_gpc，也叫魔术引号，作用是判断用户提交的数据，包括有get、post、cookie过来的数据里面的特殊字符增加转义字符”\”，以确保这些数据不会因为特殊字符引起的污染而出现致命的错误。单引号(‘)、双引号(“)、反斜线（\）等字符都会被加上反斜线。</p>
<p>因为单引号和双引号里面的内容都是字符串，如果我们输入的东西不能闭合掉单引号双引号，就无法产生sql注入，在新版本中虽然取消了魔术引号，但是很多cms依然会用一些函数替代，比如addslashes()等。</p>
<p>那么我们怎么逃逸出这个转义呢？这时候可以使用宽字节注入。</p>
<p>原理：如果程序设计数据库编码的时候设置了非英文编码，php发送请求到mysql时经过一次gbk编码，因为gbk是双字节编码，当设置gbk编码后，遇到了连续两个字节都符合gbk取值范围，会自动解析成一个汉字，输入%df%27，本来\会转义%27（’）,但\（%5c）的编码数为92，%df的编码数为223，符合取值范围，于是%df%5c会解析成为一个汉字“運”，单引号就逃逸了出来，从而绕过转义造成注入。</p>
<ul>
<li>注：1.POST注入并不会进行URL转码，所以需要改hex。</li>
<li>2.在查询时用到的表名字段名不能用原来的‘admin’形式，这时候可以转换十六进制，或者用子查询。</li>
<li>3.还可以用汉字绕过。</li>
</ul>
<h3 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h3><p>在SQL中，分号表示一条SQL语句的介绍，在结束语句后再构造一条语句，就会造成堆叠注入。</p>
<h3 id="DNSlog注入"><a href="#DNSlog注入" class="headerlink" title="DNSlog注入"></a>DNSlog注入</h3><p>利用场景：在某些无法直接利用漏洞获得回显时如果用盲注来做效率低下且容易被waf拦截，但是目标可以发起请求，这个时候我们可以通过DNS解析把我们想要获得的数据外带出来。</p>
<p>注入过程：通过子查询将内容拼接到域名内，让load_file()去访问共享文件，访问的域名被记录，读取远程共享文件，通过拼接出函数做查询，拼接到域名中，访问时将访问服务器，记录后查询该日志。</p>
<p>这里需要用到一个mysql函数LOAD_FILE()：读取一个文件并将其内容作为字符串返回。</p>
]]></content>
      <categories>
        <category>web漏洞</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title>train-www-robots</title>
    <url>/2022/09/11/train-www-robots/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="training-www-Robots"><a href="#training-www-Robots" class="headerlink" title="training-www-Robots"></a>training-www-Robots</h2><h3 id="考察的知识点"><a href="#考察的知识点" class="headerlink" title="考察的知识点"></a>考察的知识点</h3><p>robots.txt 文件是一个文本文件，使用任何一个常见的文 本编辑器，比如 Windows 系统自带的 Notepad，就可以创 建和编辑它[1] 。robots.txt 是一个协议，而不是一个命令。 robots.txt 是搜索引擎中访问网站的时候要查看的第一个 文件。robots.txt 文件告诉蜘蛛程序在服务器上什么文件 是可以被查看的。 当一个搜索蜘蛛访问一个站点时，它会首先检查该站点根 目录下是否存在 robots.txt，如果存在，搜索机器人就会 按照该文件中的内容来确定访问的范围；如果该文件不存 在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保 护的页面。百度官方建议，仅当您的网站包含不希望被搜 索引擎收录的内容时，才需要使用 robots.txt 文件。如果 您希望搜索引擎收录网站上所有内容，请勿建立 robots.txt 文件。 如果将网站视为酒店里的一个房间，robots.txt 就是主人 在房间门口悬挂的“请勿打扰”或“欢迎打扫”的提示牌。这 个文件告诉来访的搜索引擎哪些房间可以进入和参观，哪 些房间因为存放贵重物品，或可能涉及住户及访客的隐私 而不对搜索引擎开放。但 robots.txt 不是命令，也不是防 火墙，如同守门人无法阻止窃贼等恶意闯入者。</p>
<p><a href="https://zhuanlan.zhihu.com/p/29675312#:~:text=%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFRobots%E5%8D%8F%E8%AE%AE%EF%BC%9F,Robots%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B9%9F%E7%A7%B0%E4%B8%BA%E7%88%AC%E8%99%AB%E5%8D%8F%E8%AE%AE%E3%80%81%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8D%8F%E8%AE%AE%E7%AD%89%EF%BC%89%E7%9A%84%E5%85%A8%E7%A7%B0%E6%98%AF%E2%80%9C%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E6%8E%92%E9%99%A4%E6%A0%87%E5%87%86%E2%80%9D%EF%BC%8Crobots.txt%E6%98%AF%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E8%AE%BF%E9%97%AE%E7%BD%91%E7%AB%99%E6%97%B6%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%9F%A5%E7%9C%8B%E7%9A%84%E6%96%87%E4%BB%B6%EF%BC%8C%E5%BD%93%E6%88%91%E4%BB%AC%E7%BD%91%E7%AB%99%E6%9C%89%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%E4%B8%8D%E5%B8%8C%E6%9C%9B%E6%94%B6%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%8A%93%E5%8F%96%E6%97%B6%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87Robots%E5%8D%8F%E8%AE%AE%E6%9D%A5%E5%91%8A%E8%AF%89%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%93%AA%E4%BA%9B%E9%A1%B5%E9%9D%A2%E6%98%AF%E4%B8%8D%E8%83%BD%E6%8A%93%E5%8F%96%E7%9A%84%EF%BC%8C%E5%A4%A7%E5%A4%9A%E7%94%A8%E6%9D%A5%E4%BF%9D%E6%8A%A4%E7%BD%91%E7%AB%99%E7%9A%84%E9%9A%90%E7%A7%81%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E6%AD%BB%E9%93%BE%E3%80%81%E9%87%8D%E5%A4%8D%E9%A1%B5%E9%9D%A2%E7%AD%89%E7%AD%89%E3%80%82">什么是robots协议？robots.txt文件怎么写？ - 知乎 (zhihu.com)</a></p>
<p><img src="/../images/traning-www-robots/image-20230910204135962.png" alt="image-20230910204135962"></p>
<p>打开网页得到这个阅读一下，发现使用robots</p>
<p>在网页链接加上robots.txt</p>
<p><img src="/../images/traning-www-robots/image-20230910204201240.png" alt="image-20230910204201240"></p>
<p>看到flag信息查看flag</p>
<p><img src="/../images/traning-www-robots/image-20230910204211916.png" alt="image-20230910204211916"></p>
<p>拿到flag。</p>
]]></content>
      <categories>
        <category>攻防世界</category>
      </categories>
      <tags>
        <tag>-web -robots</tag>
      </tags>
  </entry>
  <entry>
    <title>upload-labs1</title>
    <url>/2023/09/14/upload-labs1/</url>
    <content><![CDATA[<h2 id="upload-labs-1"><a href="#upload-labs-1" class="headerlink" title="upload-labs-1"></a>upload-labs-1</h2><p><img src="/../images/upload-labs1/image-20230914142612836.png" alt="image-20230914142612836"></p>
<h3 id="关卡简介："><a href="#关卡简介：" class="headerlink" title="关卡简介："></a>关卡简介：</h3><p>上传点使用前端来验证后缀名，使用bp绕过上传木马脚本获取webshell。</p>
<h3 id="查看源码"><a href="#查看源码" class="headerlink" title="查看源码"></a>查看源码</h3><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">checkFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> file <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByName</span><span class="token punctuation">(</span><span class="token string">' upload_file'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>file <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> file <span class="token operator">==</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"请选择要上传的文件!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//定义允许上传的文件类型</span>
    <span class="token keyword">var</span> allow_ext <span class="token operator">=</span> <span class="token string">".jpg|.png|.gif"</span><span class="token punctuation">;</span>
    <span class="token comment">//提取上传文件的类型</span>
    <span class="token keyword">var</span> ext_name <span class="token operator">=</span> file<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//判断上传文件类型是否允许上传</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>allow_ext<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>ext_name <span class="token operator">+</span> <span class="token string">"|"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> errMsg <span class="token operator">=</span> <span class="token string">"该文件不允许上传，请上传"</span> <span class="token operator">+</span> allow_ext <span class="token operator">+</span> <span class="token string">"类型的文件,当前文件类型为："</span> <span class="token operator">+</span> ext_name<span class="token punctuation">;</span>
        <span class="token function">alert</span><span class="token punctuation">(</span>errMsg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>

<p>只允许上传.jpg|.png|.gif类型文件</p>
<p><img src="/../../../zy/Documents/image-20230914150230885.png" alt="image-20230914150230885"></p>
<p>1.查看前端代码删除check函数，或者禁用js</p>
<p><img src="/../images/upload-labs1/image-20230914150556990.png" alt="image-20230914150556990"></p>
<p>2.bp抓包修改后缀</p>
]]></content>
      <tags>
        <tag>uoload-labs</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传</title>
    <url>/2023/09/14/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><p><img src="/../images/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/1627433334141-cb693e43-53e8-4e28-80b9-b2c08e23f2f6.png" alt="web漏洞文件上传.png"></p>
<h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>在某处用户可以上传文件到服务器端，比如个人资料，头像，且后端不对用户上传的文件做处理，攻击者可以利用这个功能上传恶意文件，比如木马，病毒，恶意脚本，后门等。</p>
<h2 id="利用："><a href="#利用：" class="headerlink" title="利用："></a>利用：</h2><p>各种绕过，上传一句话木马。</p>
<p><img src="/../images/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/1627433817849-28573285-fa9c-4d1d-9864-2f822f372ee5.png" alt="文件上传利用思路.png"></p>
<h2 id="文件上传漏洞如何查找及判断"><a href="#文件上传漏洞如何查找及判断" class="headerlink" title="文件上传漏洞如何查找及判断?"></a>文件上传漏洞如何查找及判断?</h2><p>1.黑盒查找：通过工具扫描网站敏感文件、路径，以期获得文件上传地址。或者通过类似于会员中心的上传图片功能进行漏洞测试。网站后台也有上传功能（后台权限不等同于网站权限）。</p>
<p>2.白盒测试：审计代码，寻找上传漏洞。通过抓包、上传等操作判断漏洞是否有效。</p>
<h3 id="文件上传常见验证"><a href="#文件上传常见验证" class="headerlink" title="文件上传常见验证:"></a>文件上传常见验证:</h3><p>后缀名，类型，文件头等<br>后缀名:黑名单,白名单<br>文件类型:MIME<br>信息文件头:内容头信息</p>
<p>简要上传表单代码分析解释</p>
<h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><pre class="language-none"><code class="language-none">trim() 函数移除字符串两侧的空白字符或其他预定义字符。

str_ireplace() 函数替换字符串中的一些字符（不区分大小写）。

substr() 函数返回字符串的一部分。

strrpos() 函数查找字符串在另一字符串中最后一次出现的位置。</code></pre>



<h2 id="防御："><a href="#防御：" class="headerlink" title="防御："></a>防御：</h2><p>1.前端js脚本检测后缀名。（可以有burp抓包修改文件后缀名绕过）</p>
<p>2.后端黑白名单检测（黑名单检测可以通过测试检测规则绕过，白名单检测可以用00截断绕过）</p>
<p>3.content-type检测过滤（bp抓包修改content-type绕过）</p>
<p>4.getimagesize(_)函数检测图片大小是否正常（将木马写入图片绕过）</p>
<p>5.图片二次渲染</p>
<p>6.文件重命名</p>
<h2 id="常见绕过方式"><a href="#常见绕过方式" class="headerlink" title="常见绕过方式"></a>常见绕过方式</h2><p>数据溢出-防匹配(xxx.. .)</p>
<p>符号变异-防匹配（’” ;)</p>
<p>数据截断-防匹配(%00 ;换行)</p>
<p>重复数据-防匹配(参数多次)</p>
<h2 id="上传的参数名解析"><a href="#上传的参数名解析" class="headerlink" title="上传的参数名解析"></a>上传的参数名解析</h2><p>可以修改的东西有？</p>
<pre class="language-none"><code class="language-none">Content-Disposition:	一般可更改

name:	表单参数值，不能更改

filename :文件名，可以更改

Content-Type:文件MIME，视情况更改
</code></pre>

]]></content>
      <tags>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>owasp top10</title>
    <url>/2024/03/05/owasp-top10/</url>
    <content><![CDATA[<h2 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h2><p>注入通常是指将不受信任的数据作为命令或查询的一部分发送到解析器时，会产生注入SQL注入、OS注入和LDAP注入的缺陷。攻击者的恶意数据可以诱使解析器在没有适当授权的情况下执行非预期命令访问数据。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>一般常见的SQL注入和OS注入</p>
<ul>
<li><p>SQL注入：</p>
</li>
<li><p>SQL注入防御：</p>
<ol>
<li>对输入进行严格过滤和转义</li>
<li>关闭错误回显</li>
<li>限制SQL服务的远程访问，只开放给特定开发人员</li>
<li>代码审计–最有效的检测应用程序的注入风险的方法之一</li>
<li>使用成熟的waf</li>
</ol>
</li>
<li><p>os注入：web开发使用的编程语言中，大多数能通过shell执行os命令。通过shell执行OS命令时或者开发中用到某个方法其内部利用了shell时，就有可能出现OS命令被任意执行的情况。</p>
</li>
<li><p>OS注入的防御：</p>
<ol>
<li>使用安全的函数对传递给OS命令参数进行转义</li>
<li>不将外界传入的字符串传递给命令行参数</li>
<li>选择不调用OS命令的方法实现</li>
</ol>
<p>（不利用 shell的功能，既能杜绝os命令注入漏洞，又消除了调用os命令的系统开销，提高应用性能）</p>
</li>
</ul>
<h2 id="敏感数据泄露"><a href="#敏感数据泄露" class="headerlink" title="敏感数据泄露"></a>敏感数据泄露</h2><p>原理：应用维护或者开发人员无意间上传敏感数据，如GitHub文件泄露敏感数据文件的权限设置错误。</p>
<p>常见攻击方式主要是扫描应用程序获得敏感数据</p>
<p>防御：</p>
<ol>
<li>对系统处理、存储或传输的数据分类进行访问控制。</li>
<li>确保存储的敏感数据被加密</li>
<li>确保使用了强大的标准算法或密码、参数。协议和秘钥，</li>
<li>禁止缓存对包含敏感数据的响应</li>
</ol>
<h2 id="失效的身份认证"><a href="#失效的身份认证" class="headerlink" title="失效的身份认证"></a>失效的身份认证</h2><p>原理：应用中负责认证会话管理的部分没有正确实现，使得攻击者得以泄露密码，口令或令牌，进而可能获取其他用户的身份。</p>
<p>影响：</p>
<ul>
<li>盗用账号与身份（撞库，弱密码尝试之类）</li>
</ul>
<p>防御：</p>
<ul>
<li>使用强密码</li>
<li>限制或延迟失败的登录尝试，并记录所有失败尝试</li>
<li>网站应该具备良好的权限控制与管理</li>
<li>使用SSL对数据流进行加密</li>
</ul>
<h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>往网站上注入恶意脚本，当用户浏览网页时候恶意代码执行，从而获取用户敏感信息。分为存储型，DOM型，反射型</p>
<h4 id="反射型XSS："><a href="#反射型XSS：" class="headerlink" title="反射型XSS："></a>反射型XSS：</h4><p>非持久化攻击，需要欺骗用户点击链接才能触发XSS代码。应用程序或API包括未验证和未转义的用户输入作为html输出的一部分。</p>
<h4 id="存储型XSS："><a href="#存储型XSS：" class="headerlink" title="存储型XSS："></a>存储型XSS：</h4><p> 持久化攻击，代码存在服务器中，如个人信息里。访问该页面时候触发代码执行，容易造成蠕虫，盗窃cookie。</p>
<h4 id="DOM型："><a href="#DOM型：" class="headerlink" title="DOM型："></a>DOM型：</h4><p>不经过后端，domxss是基于文档对象模型（document object model，dom)的漏洞</p>
<p>，攻击者向服务器发送一个带有恶意js代码的请求，服务器的响应不i会以任何形式包含攻击者的脚本。当用户的浏览器处理这个响应时，DOM对象就会处理XSS代码，导致XSS漏洞。</p>
<h4 id="防御："><a href="#防御：" class="headerlink" title="防御："></a>防御：</h4><ul>
<li>存储型：后台编写过滤器，对一些HTML标签和特殊的字符进行转义</li>
<li>反射型：对特殊字符转义</li>
<li>dom:检测是否包含一些特殊的函数可以造成危害的地方</li>
<li>使用字段转义的xss框架，如react js</li>
<li>启用CSP（content security policy），这是一种对抗XSS纵深防御弥补控制。</li>
</ul>
<h2 id="外部实体（XXE）"><a href="#外部实体（XXE）" class="headerlink" title="外部实体（XXE）"></a>外部实体（XXE）</h2><p>XXE（XML external entity injection）外部实体注入漏洞，XML在引用外部实体时候，攻击者可以构造恶意的XML代码，以造成任意文件读取、命令执行甚至是中断服务器。</p>
<p>主要成因是因为XML协议文档本身的设计特性，可以引入外部的资源，定义XML文件时使用的外部实体引入功能。 </p>
<p>影响：读取服务器敏感资料比如/etc/password</p>
<p>读取源码</p>
<p>防御：关闭DTD，禁止外部实体引入，过滤用户提交的XML数据</p>
<h2 id="安全配置错误"><a href="#安全配置错误" class="headerlink" title="安全配置错误"></a>安全配置错误</h2><p>原理：操作者不当配置（默认配置，临时配置，开源云存储，HTTP标头配置），导致攻击者可以利用这些配置获取到更高权限，安全配置错误可以发生在各个层面，包含平台、web服务器、数据库、架构和代码</p>
<p>防御：</p>
<ul>
<li>使用的服务不包含任何不必要的功能、组件、文档和用例，移除或不安装不适用的功能和框架</li>
<li>即使检测系统服务版本打上漏洞补丁</li>
<li>自动化安装部署</li>
</ul>
<h2 id="失效访问控制"><a href="#失效访问控制" class="headerlink" title="失效访问控制"></a>失效访问控制</h2><p>水平越权：系统只验证能够访问数据的角色没有对数据做细分导致A能访问B的数据。</p>
<p>垂直越权：后台未对权限做限制，导致攻击者可以通过猜测其他管理页面的url或者敏感的参数信息变更权限。</p>
<p>防御：</p>
<ul>
<li>对参数的白名单过滤</li>
<li>对权限的控制管理重新设计与限制</li>
<li>前后端同时校验，双重验证机制</li>
<li>用户注销后使其jwt令牌失效</li>
</ul>
<h2 id="不安全的反序列化"><a href="#不安全的反序列化" class="headerlink" title="不安全的反序列化"></a>不安全的反序列化</h2><p>介绍：</p>
<p>序列化：序列化 (Serialization)是将对象的状态信息转换为可以存储或传输(一般是以二进制的形式保存)的形式的过程。<br>反序列化： 与序列化的过程刚好相反。</p>
<p>原理：如果应用对恶意构造的用户输入数据进行反序列化，会产生非预期对象，从而可能导致远程代码执行。或者应用中存在可以反序列化过程中或者之后被改变行为的类，则攻击者可以通过改变应用逻辑或者失实现远程代码执行攻击，称为对象和数据结构攻击。</p>
<p>防御</p>
<ol>
<li>对序列化对象进行完整性检测，比如数字签名防止数据篡改或恶意对象。</li>
<li>在反序列化过程中强制严格的类型限制</li>
<li>在低权限环境中独立运行反序列化代码</li>
<li>不接受来自不信任源的序列化对象，或使用只允许原始数据类型的序列化媒体</li>
<li>对反序列化过程进行日志记录，监控反序列化过程，在发现疑似反序列化攻击时进行警报。</li>
</ol>
<h2 id="使用含已知漏洞的组件"><a href="#使用含已知漏洞的组件" class="headerlink" title="使用含已知漏洞的组件"></a>使用含已知漏洞的组件</h2><p>限制的服务器都需要使用很多组件，库、框架等软件组件和应用有着相同权限。如果存在有漏洞的组件，那么攻击就能导致数据泄露甚至控制服务器。组件中的漏洞会导致整个应用和API安全性下降。</p>
<p>防御：</p>
<ul>
<li>移除不使用的功能组件</li>
<li>从正规渠道获取组件</li>
<li>及时更新、修复组件漏洞</li>
</ul>
<h2 id="不足的日志记录和监控"><a href="#不足的日志记录和监控" class="headerlink" title="不足的日志记录和监控"></a>不足的日志记录和监控</h2><p>日志和监控不足，再加上缺失或无效的事件响应，允许攻击者进一步攻击系统。</p>
<p>防御：</p>
<ul>
<li>启用日志监控、告警机制</li>
<li>尽可能的完整记录所有日志</li>
</ul>
<h2 id="其他常见web漏洞"><a href="#其他常见web漏洞" class="headerlink" title="其他常见web漏洞"></a>其他常见web漏洞</h2><hr>
<h2 id="CSRF跨站请求伪造"><a href="#CSRF跨站请求伪造" class="headerlink" title="CSRF跨站请求伪造"></a>CSRF跨站请求伪造</h2><p><img src="/../images/owasp-top10/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZW5saWppYW4=,size_16,color_FFFFFF,t_70.png"></p>
<p>简单来说就是用户拥有网站A的cookie,攻击者诱导用户点击网站B从而获得用户cookie假装为用户去访问网站A</p>
<p>防御：</p>
<ul>
<li>在请求参数中增加一个随机token</li>
<li>敏感操作使用POST以表单形式提交，避免token泄露。</li>
</ul>
<h2 id="SSRF服务器端请求伪造"><a href="#SSRF服务器端请求伪造" class="headerlink" title="SSRF服务器端请求伪造"></a>SSRF服务器端请求伪造</h2><p>SSRF是一种由攻击者构造形成由服务器端发起请求的安全的一个安全漏洞。</p>
<p>原理：服务器端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。</p>
<p>ssrf是利用存在缺陷的web应用作为代理攻击远程和本地服务器。</p>
<p>防御：</p>
<ol>
<li>过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一类型的文件，那么在返回结果展示给用户之前先验证返回是信息是否符合标准。</li>
<li>统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</li>
<li>限制请求的端口为哦HTTP常用端口，如80，8080，8090，443</li>
<li>黑名单内网IP。避免应用被用来获取内网数据，攻击内网。</li>
<li>禁止不需要的协议。</li>
</ol>
<p>参考文章：</p>
<p><a href="https://blog.csdn.net/qq_43378996/article/details/124050308">SSRF漏洞原理攻击与防御(超详细总结)-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/angry_program/article/details/107855078">目录穿越/遍历漏洞 – 学习笔记_目录遍历漏洞描述-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_32261191/article/details/101686779">常见的Web漏洞——命令注入_命令注入漏洞-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/weixin_50464560/article/details/120926097">WAF绕过思路整理(挺全)_waf绕过总结-CSDN博客</a></p>
]]></content>
      <categories>
        <category>web漏洞</category>
      </categories>
      <tags>
        <tag>常见web漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>随便看看</title>
    <url>/2024/04/14/%E9%9A%8F%E4%BE%BF%E7%9C%8B%E7%9C%8B/</url>
    <content><![CDATA[<h2 id="渗透测试流程"><a href="#渗透测试流程" class="headerlink" title="渗透测试流程"></a>渗透测试流程</h2><h2 id="给你一个网站如何进行渗透测试"><a href="#给你一个网站如何进行渗透测试" class="headerlink" title="给你一个网站如何进行渗透测试"></a>给你一个网站如何进行渗透测试</h2><p><a href="https://zhuanlan.zhihu.com/p/25605198">给你一个网站你是如何来渗透测试的? - 知乎 (zhihu.com)</a></p>
<p>漏洞扫描工具：</p>
<p><a href="https://blog.csdn.net/qq_37776764/article/details/130713025">Nessus、AWVS、Appscan、OWASP漏洞扫描工具的区别（介绍、测试对象对比、优劣对比、使用选择）_nessus和awvs区别_网络安全刚子的博客-CSDN博客</a></p>
<h2 id="linux，windows-提权手法有哪些，讲一讲"><a href="#linux，windows-提权手法有哪些，讲一讲" class="headerlink" title="linux，windows 提权手法有哪些，讲一讲"></a>linux，windows 提权手法有哪些，讲一讲</h2><p><a href="https://blog.csdn.net/lkbzhj/article/details/130182211">windows和linux常见的提权方法_BTY@BTY的博客-CSDN博客</a></p>
<p>[Windows常用提权方法 (ﾟ益ﾟメ) 渗透测试_win提权_寻_觅的博客-CSDN博客](<a href="https://blog.csdn.net/qq_39611230/article/details/114745974#:~:text=%E6%8F%90%E6%9D%83%E8%AF%B4%E6%98%8E">https://blog.csdn.net/qq_39611230/article/details/114745974#:~:text=提权说明</a>. Windows作为一个非常完善和成熟的系统体系%2C有着十分强大的权限管理体系%2C一般成熟的项目中%2C也都会有着比较完善的权限分级体系%2C我们一般能获取到的权限都是 普通用户权限或管理员权限 %2CWindows中提权主要指的就是将我们的权限提升到系统管理员 (system)权限。. 提权不仅可以利用系统漏洞进行%2C一些软件程序的缺陷也可以被利用作为提权的一种方式。. 权限等级%3A 普通用户,&lt; 管理员 (administrator或管理员组其他用户) &lt; 系统管理员%2C超级管理员 (system) windows漏洞汇总%3A https%3A%2F%2Fgithub.com%2FSecWiki%2Fwindows-kernel-exploits.)</p>
<p><a href="https://zhuanlan.zhihu.com/p/304572787">Linux 提权原理及十种提权姿势详解 - 知乎 (zhihu.com)</a></p>
<p>（选几个了解）</p>
<h2 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h2><p>在渗透测试中，经常会使用到端口转发和代理。</p>
<p>端口转发是转发一个网络端口从一个网络节点到另一个网络节点的行为。</p>
<p>端口转发和代理在渗透测试中有广泛的应用，可以帮助渗透测试人员隐藏其真实身份、绕过安全措施，并获取更多的攻击面。以下是一些常见的应用场景：</p>
<ol>
<li>隐藏真实IP地址：通过使用代理服务器，渗透测试人员可以隐藏其真实IP地址，使其活动更难被追踪或识别。</li>
<li>绕过防火墙和入侵检测系统：通过使用端口转发和代理，可以绕过目标网络中的防火墙和入侵检测系统，使得攻击者能够更轻易地访问目标系统。</li>
<li>穿越NAT和防火墙：在网络渗透测试中，目标系统可能位于NAT（网络地址转换）或防火墙后面，使得直接访问变得困难。使用端口转发和代理可以帮助渗透测试人员建立起与目标系统之间的通信通道。</li>
<li>数据流量转发和中继：渗透测试人员可以使用端口转发和代理来转发和中继数据流量，以便在攻击过程中传递恶意代码、执行命令或获取敏感数据。</li>
<li>模拟攻击：通过使用代理服务器，渗透测试人员可以模拟攻击者的行为，例如使用匿名代理服务器发送恶意请求、执行暴力破解等操作，以评估目标系统的安全性和弱点。</li>
</ol>
<p><a href="https://zhuanlan.zhihu.com/p/46804075">渗透基础——端口转发与代理 - 知乎 (zhihu.com)</a></p>
<p><a href="https://www.freebuf.com/articles/web/170970.html">内网渗透之端口转发与代理工具总结 - FreeBuf网络安全行业门户</a></p>
<p>常用工具有lcx(端口转发)</p>
<p>nc反弹，proxychains</p>
<h2 id="打点一般会用什么漏洞"><a href="#打点一般会用什么漏洞" class="headerlink" title="打点一般会用什么漏洞"></a>打点一般会用什么漏洞</h2><p>打点（Foothold）是指获取对目标系统的初始访问权限或建立初始的控制点。</p>
<h2 id="擅长-web-还是内网"><a href="#擅长-web-还是内网" class="headerlink" title="擅长 web 还是内网"></a>擅长 web 还是内网</h2><h2 id="被拿-shell-了如何处理"><a href="#被拿-shell-了如何处理" class="headerlink" title="被拿 shell 了如何处理"></a>被拿 shell 了如何处理</h2><p>PDCERF 模型，简答<strong>排查、清除、看看可有即使修复的可能，不得已就关站</strong></p>
<p>Prepare（准备）：准备用来检测的工具和人</p>
<p>Detection（检测）：紧急事件监测：包括防火墙、系统、web 服务器、IDS/WAF/SIEM 中的日志，不正常或者是执行了越权操作的用户，甚至还有管理员的报告</p>
<p>Containment（抑制）：首先先控制受害范围，不要让攻击的影响继续蔓延到其他的 IT 资产和业务环境，切记不要直接一股脑的投入全部精力到封堵后门。紧接着要做的是去寻找根源原因，彻底解决，封堵攻击源，把业务恢复到更张水平</p>
<p>Eradication（根除）</p>
<p>Recover（恢复）</p>
<p>Follow-Up（跟踪）：根据各种监控去确定没有其他的攻击行为和攻击向量，紧接着就是开会反省此次事件，写报告，持续改进工作流程和工作缓解</p>
<h2 id="设备出现了误报如何处置（日志）"><a href="#设备出现了误报如何处置（日志）" class="headerlink" title="设备出现了误报如何处置（日志）"></a>设备出现了误报如何处置（日志）</h2><p>答：要确认设备是否误报，应当先去查看设备的完整流量日志等信息。在护网过程中如果确实存在异常流量应当及时进行上报，确认是误报后做好事件记录。</p>
<h2 id="如何查看区分是扫描流量和手动流量"><a href="#如何查看区分是扫描流量和手动流量" class="headerlink" title="如何查看区分是扫描流量和手动流量"></a>如何查看区分是扫描流量和手动流量</h2><p>答：扫描的数据量大，请求流量有规律可寻，手动流量请求少 间隔略长</p>
<h2 id="拿到一台域内的主机之后，怎么进行域渗透"><a href="#拿到一台域内的主机之后，怎么进行域渗透" class="headerlink" title="拿到一台域内的主机之后，怎么进行域渗透"></a>拿到一台域内的主机之后，怎么进行域渗透</h2><p><a href="https://www.freebuf.com/company-information/172630.html">干货！内网渗透测试之域渗透详解！收藏！ - FreeBuf网络安全行业门户</a></p>
<p><a href="https://blog.csdn.net/q20010619/article/details/121588113">内网渗透-完整的域渗透_OceanSec的博客-CSDN博客</a></p>
<p>msf工具多了解了解</p>
<h2 id="内网的-IP-地址有哪些"><a href="#内网的-IP-地址有哪些" class="headerlink" title="内网的 IP 地址有哪些"></a>内网的 IP 地址有哪些</h2><p>常见的内网IP段有：</p>
<p>10.0.0.0/8<br>10.0.0.0 - 10.255.255.255<br>172.16.0.0/12<br>172.16.0.0 - 172.31.255.255<br>192.168.0.0/16<br>192.168.0.0 - 192.168.255.255<br>以上三个网段分别属于A、B、C三类IP地址</p>
<h2 id="如果让你写个工具，思路是什么-或者别人工具的实现原理"><a href="#如果让你写个工具，思路是什么-或者别人工具的实现原理" class="headerlink" title="如果让你写个工具，思路是什么(或者别人工具的实现原理)"></a>如果让你写个工具，思路是什么(或者别人工具的实现原理)</h2><p>确定需求、编程语言、设计架构、编写代码、测试和优化、发布和维护。</p>
<p><a href="https://wenku.baidu.com/view/6928c01ba16925c52cc58bd63186bceb19e8edac.html?_wkts_=1694418257701">安全工具编写思路 - 百度文库 (baidu.com)</a></p>
<p>sqlmap工具原理：</p>
<ol>
<li>参数识别：SQLMap会分析目标URL，并识别出可能存在SQL注入的参数。它会检查GET和POST请求中的参数，并尝试注入恶意的SQL语句。</li>
<li>注入检测：SQLMap使用各种注入技术和测试向量来检测目标应用程序的SQL注入漏洞。它会向目标应用程序发送特定的注入字符串，并观察返回的响应，以确定是否存在注入漏洞。</li>
<li>注入漏洞利用：一旦SQLMap确认目标应用程序存在注入漏洞，它会尝试利用该漏洞来执行进一步的操作。这包括获取数据库的信息、提取敏感数据、绕过身份验证、执行系统命令等。</li>
<li>基于启发式的攻击：SQLMap使用一系列启发式技术来自动选择合适的注入技术和测试向量。它会根据目标应用程序的响应和特征来调整注入策略，并尝试多个注入点以获取最佳结果。</li>
<li>漏洞报告和输出：SQLMap会生成详细的报告，列出发现的注入漏洞、提取的数据和执行的操作。这些报告可以帮助用户了解目标应用程序的安全状况，并提供进一步的分析和建议</li>
</ol>
<h2 id="后面的发展规划-学习方向"><a href="#后面的发展规划-学习方向" class="headerlink" title="后面的发展规划(学习方向)"></a>后面的发展规划(学习方向)</h2><ol>
<li><p>深入研究网络和系统安全：学习网络和系统的底层工作原理，包括网络协议、操作系统、网络架构等。深入了解攻击技术和防御机制，包括网络攻击、漏洞利用、入侵检测与防御等。</p>
</li>
<li><p>研究漏洞分析和渗透测试：学习漏洞分析的方法和技术，了解常见的软件漏洞类型和利用方式。通过渗透测试来评估网络和应用程序的安全性，并提供修复建议。</p>
</li>
<li><p>学习人工智能和机器学习在安全中的应用：人工智能和机器学习在安全领域具有广泛的应用，包括威胁检测、异常行为分析、网络流量分析等。了解机器学习算法和数据分析技术，并应用于网络安全的相关领域。</p>
</li>
<li><p>深入了解法律和合规要求：学习与网络安全相关的法律法规和合规要求，包括数据保护法、隐私法、网络安全法等。了解合规框架和审计标准，并能够帮助组织遵守相关法规。</p>
</li>
<li><p>持续学习和跟踪最新趋势：网络安全领域发展迅速，新的威胁和技术不断涌现。参与安全社区、参加安全会议和培训，持续学习并跟踪最新的趋势和技术。</p>
</li>
<li><p>考虑获取相关认证：网络安全领域有许多行业认可的安全认证，如CISSP、NISP等。</p>
<p>主要是多动手实践。</p>
</li>
</ol>
<h2 id="常见的-SQL-注入类型有哪些？并写出-sqlmap-检测-SQL-注入的命令？SQLMAPAPI"><a href="#常见的-SQL-注入类型有哪些？并写出-sqlmap-检测-SQL-注入的命令？SQLMAPAPI" class="headerlink" title="常见的 SQL 注入类型有哪些？并写出 sqlmap 检测 SQL 注入的命令？SQLMAPAPI"></a>常见的 SQL 注入类型有哪些？并写出 sqlmap 检测 SQL 注入的命令？SQLMAPAPI</h2><p><a href="https://www.freebuf.com/articles/web/256532.html">初学SQL注入之常见的几种注入类型介绍 - FreeBuf网络安全行业门户</a></p>
<ol>
<li>扫描目标URL：sqlmap -u &lt;目标URL&gt;</li>
<li>扫描目标URL并检测注入：sqlmap -u &lt;目标URL&gt; –dbs</li>
<li>指定注入参数进行测试：sqlmap -u &lt;目标URL&gt; -p &lt;注入参数&gt;</li>
<li>指定数据库类型进行测试：sqlmap -u &lt;目标URL&gt; –dbms &lt;数据库类型&gt;</li>
<li>使用Cookie进行测试：sqlmap -u &lt;目标URL&gt; –cookie “&lt;Cookie数据&gt;”</li>
<li>执行具体的SQL注入攻击：sqlmap -u &lt;目标URL&gt; –data “&lt;POST数据&gt;” –method POST –level 5 –risk 3</li>
</ol>
<p>SQLMapAPI 是 SQLMap 工具的一个组件，SQLMapAPI 提供了一组 RESTful 风格的 API，可以通过发送 HTTP 请求与 SQLMap 进行通信。使用 SQLMapAPI，你可以编写自定义脚本或集成其他应用程序来自动化执行 SQL 注入测试和利用。</p>
<h2 id="内网如何反弹-shell，反弹的-shell-流量如何隐蔽"><a href="#内网如何反弹-shell，反弹的-shell-流量如何隐蔽" class="headerlink" title="内网如何反弹 shell，反弹的 shell 流量如何隐蔽"></a>内网如何反弹 shell，反弹的 shell 流量如何隐蔽</h2><p><a href="https://zhuanlan.zhihu.com/p/607054390">常用内网反弹shell方法一览 - 知乎 (zhihu.com)</a></p>
<p><a href="https://www.freebuf.com/articles/web/268651.html">内网渗透——反弹shell详解 - FreeBuf网络安全行业门户</a></p>
<h2 id="如何拿shell"><a href="#如何拿shell" class="headerlink" title="如何拿shell"></a>如何拿shell</h2><p><a href="https://blog.csdn.net/zdy8023/article/details/89059137">拿shell的一些方式_努力奋斗的小青年的博客-CSDN博客</a></p>
<h2 id="注入攻击原理是什么？如何找注入点？如何判断注入点？"><a href="#注入攻击原理是什么？如何找注入点？如何判断注入点？" class="headerlink" title="注入攻击原理是什么？如何找注入点？如何判断注入点？"></a>注入攻击原理是什么？如何找注入点？如何判断注入点？</h2><p>sql注入，xss，LDAP注入，命令注入了解这些。</p>
<p><a href="https://segmentfault.com/a/1190000037581113">注入攻击笔记 - 个人文章 - SegmentFault 思否</a></p>
<h2 id="owasp-top10"><a href="#owasp-top10" class="headerlink" title="owasp top10"></a>owasp top10</h2><p><a href="https://zhuanlan.zhihu.com/p/374512917">owasp top10 | 十大常见漏洞详解 - 知乎 (zhihu.com)</a></p>
<h2 id="CDn-负载均衡你知道吧-如果攻击方使用的是一个有挂了-CDn-负载均衡的服务器来攻击你，你要怎么溯源到目标的真实-IP-地址呢"><a href="#CDn-负载均衡你知道吧-如果攻击方使用的是一个有挂了-CDn-负载均衡的服务器来攻击你，你要怎么溯源到目标的真实-IP-地址呢" class="headerlink" title="CDn 负载均衡你知道吧?如果攻击方使用的是一个有挂了 CDn 负载均衡的服务器来攻击你，你要怎么溯源到目标的真实 IP 地址呢?"></a>CDn 负载均衡你知道吧?如果攻击方使用的是一个有挂了 CDn 负载均衡的服务器来攻击你，你要怎么溯源到目标的真实 IP 地址呢?</h2><p>CDN： 是构建在数据网络上的一种分布式的内容分发网。 可以提高系统的响应速度，也可以一定程度的拦截/防御攻击。</p>
<p>多地ping，反向攻击代理拿下服务器然后日志审计</p>
<p><a href="https://zhuanlan.zhihu.com/p/589622686%EF%BC%88%E5%A4%9A%E5%9C%B0Ping">https://zhuanlan.zhihu.com/p/589622686（多地Ping</a>)</p>
<h2 id="和甲方上报-IP-地址，你要上报哪些地址呢"><a href="#和甲方上报-IP-地址，你要上报哪些地址呢" class="headerlink" title="和甲方上报 IP 地址，你要上报哪些地址呢?"></a>和甲方上报 IP 地址，你要上报哪些地址呢?</h2><p>上报攻击 ip 的地址，先判断是内网 ip 还是公网 ip，如果是内网ip，查看是否是业务白名单行为，若不是再上报进行判断。若是公网 ip，查看是否在白名单内，若不是查看是否是扫描器 ip，若是扫描器 ip，扫描对业务或者对研判产生了影响则可以上报，若不是且判断出是真实攻击 ip 也进行上报。</p>
<h2 id="如果看到一个告警ip，如何判断是否是真实攻击？"><a href="#如果看到一个告警ip，如何判断是否是真实攻击？" class="headerlink" title="如果看到一个告警ip，如何判断是否是真实攻击？"></a>如果看到一个告警ip，如何判断是否是真实攻击？</h2><p>首先，我会先判断一下ip来源，判断是内网ip还是公网ip，若为内网ip，然后对请求包的内容是否存在恶意payload，然后再根据响应包内容有执行成功的回显，若相应包中有对应的payload的回显，则可以判断为攻击成功，但是此时，需要判断下是否为业务系统的逻辑造成的和是否是工作人员在测试业务系统漏洞，若工作人员证实了该告警为自家安全ip，则认为该攻击为误报，若非自家ip且不存在逻辑因素，则可判断为内网攻陷。若为公网ip，若恶意payload利用成功，则可判断为真实攻击。</p>
<h2 id="三握手四挥手"><a href="#三握手四挥手" class="headerlink" title="三握手四挥手"></a>三握手四挥手</h2><h3 id="三握手："><a href="#三握手：" class="headerlink" title="三握手："></a>三握手：</h3><p>第一次：客户端将tcp报文的标志位SYN设置为1，随机产生一个序号值seq=j，保存在TCP首部的序列号字段里面，指明客户端想要连接的服务器端口，把该数据包发送给服务器。客服端进入SYN_SENT状态。</p>
<p>第二次：服务器端收到数据包后根据标志位SYN=1知道客服端请求建立连接，服务器端将TCP报文标志位SYN和ACK都设置为1，并且令头部确认号（Acknowledge number， 缩写ack）为j+1，（ack=seq+1），随机产生seq=k,把该数据包发送给客户端以确认连接请求。服务器端进入SYN_RCVD状态。</p>
<p>第三次:客户端收到确认检查ack，是否=j+1，ACK是否为一，如果正确将ACK标志设置为1.ack=k+1，把该数据包发送给服务器端，服务器端检查ACK是否=1，ack是否为k+1，正确则建立成功。双方进入establised状态（已建立态）</p>
<h3 id="四挥手："><a href="#四挥手：" class="headerlink" title="四挥手："></a>四挥手：</h3><p>三握手属于建立连接，四挥手属于关闭连接，</p>
<p>第一次:客户端发起挥手请求向服务器端发送标志位是FIN的报文段，设置seq。客户端进入FIN_WAIT_1态</p>
<p>第二次：服务器端收到报文向客户端发送标志位是ACK的报文段，ack为seq+1。客户端进入FIN_WAIT_2态</p>
<p>第三次:服务器端向客户端发送FIN报文段，请求关闭连接。服务器端进入LAST_ACK状态。</p>
<p>第四次:客户端收到服务器端发送的FIN报文后，发一个ACK应答，ack=seq+1。</p>
<p>等待2个MSL（报文段最大生存时间）关闭连接，为什么不直接关闭，因为要确保ACK报文发到服务器端。</p>
<p><a href="https://www.cnblogs.com/zzjdbk/p/13028290.html">三次握手和四次挥手（面试必问） - My_Dreams - 博客园 (cnblogs.com)</a></p>
<h2 id="挖过哪些洞-追问原理"><a href="#挖过哪些洞-追问原理" class="headerlink" title="挖过哪些洞?追问原理"></a>挖过哪些洞?追问原理</h2><h2 id="挖过最有意思-最难的一个洞"><a href="#挖过最有意思-最难的一个洞" class="headerlink" title="挖过最有意思/最难的一个洞"></a>挖过最有意思/最难的一个洞</h2><p>威努特<br>中国化学工程第七建设有限公司<br>长虹集团<br>大华股份2024届全球校园招聘正式启动！<br>成都安恒信息技术有限公司<br>赛力斯集团20<br>天奥电子2024届校园招聘<br>迈普通信技术股份<br>成都创信华通信息技术有限公司<br>深信服24届全球校园招聘正式启动！<br>北京人大金仓2024校园招聘全面启动！<br>成都拓尔思信息技术有限公司<br>中国建筑装饰集团校园招聘简章</p>
]]></content>
  </entry>
</search>
